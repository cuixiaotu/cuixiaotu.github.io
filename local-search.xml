<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker学习6</title>
    <link href="/2021/09/16/Docker%E5%AD%A6%E4%B9%A06/"/>
    <url>/2021/09/16/Docker%E5%AD%A6%E4%B9%A06/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习6"><a href="#Docker学习6" class="headerlink" title="Docker学习6"></a>Docker学习6</h1><h3 id="多容器应用"><a href="#多容器应用" class="headerlink" title="多容器应用"></a>多容器应用</h3><p>之前都是使用单个容器的应用，当要接入mysql时，建议分开独立部署</p><ol><li><p>不同于数据库的方式扩展 API 和前端</p></li><li><p>独立容器可以隔离稳定版本和更新版本</p></li><li><p>在生产中肯定不想在你的应用中发布你的数据库程序。</p></li><li><p>运行多个进程将需要一个进程管理器（容器只启动一个进程），增加了容器启动/关闭的复杂性</p></li></ol><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><p>如果两个容器运行在同一个网络上，则他们可以交互。</p><p>让我们连接todo app和mysql。</p><pre><code class="hljs sh"><span class="hljs-comment"># 创建容器网络</span>docker network create todo-app<span class="hljs-comment"># 启动mysql 官方文档：https://hub.docker.com/_/mysql/</span>docker run -d \     --network todo-app --network-alias mysql \     -v todo-mysql-data:/var/lib/mysql \     -e MYSQL_ROOT_PASSWORD=secret \     -e MYSQL_DATABASE=todos \     mysql:5.7<span class="hljs-comment"># 进入mysql     </span>docker <span class="hljs-built_in">exec</span> -it &lt;mysql-container-id&gt; mysql -u root -p secretshow databases;</code></pre><h3 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h3><p>使用<a href="https://github.com/nicolaka/netshoot" target="_blank" rel="noopener">nicolaka/netshoot</a> 来进行网络调试</p><pre><code class="hljs sh">docker run -it --network todo-app nicolaka/netshoot<span class="hljs-comment">#使用dig命令找出mysql 的 IP 地址。</span>dig mysql<span class="hljs-comment"># 在下图 ANSWER SECTION中可以看到mysql的解析地址</span></code></pre><p><img src="Docker%E5%AD%A6%E4%B9%A06/image-20210916161503613.png" srcset="/img/loading.gif" alt="image-20210916161503613"></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习5</title>
    <link href="/2021/09/14/Docker%E5%AD%A6%E4%B9%A05/"/>
    <url>/2021/09/14/Docker%E5%AD%A6%E4%B9%A05/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习5"><a href="#Docker学习5" class="headerlink" title="Docker学习5"></a>Docker学习5</h1><h2 id="持久化DB"><a href="#持久化DB" class="headerlink" title="持久化DB"></a>持久化DB</h2><p>在学习4中每次重启项目后，上次添加的todo list没了。当容器运行时，它会将镜像中的多个层用于其文件系统。每个容器也有自己的“暂存空间”来创建/更新/删除文件。即使使用相同的镜像，任何更改都不会在另一个容器中看到。</p><pre><code class="hljs sh"><span class="hljs-comment">#举一个栗子 </span>docker run -d ubuntu bash -c <span class="hljs-string">"shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null"</span><span class="hljs-comment">#查看运行中容器</span>docker ps<span class="hljs-comment">#宿主机上并没有该文件</span>cat /data<span class="hljs-comment">#查看容器内文件</span>docker <span class="hljs-built_in">exec</span> 8957d28f0adc（容器ID） cat /data.txt</code></pre><h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><p>volume提供将容器的特定文件系统路径连接回主机的能力。如果挂载了容器中的目录，主机上也会看到该目录中的更改。如果我们在容器重启时挂载相同的目录，我们会看到相同的文件。</p><h3 id="持久化todo-list"><a href="#持久化todo-list" class="headerlink" title="持久化todo list"></a>持久化todo list</h3><pre><code class="hljs sh"><span class="hljs-comment">#创建volume</span>docke volume create todo-db<span class="hljs-comment">#挂载volume并运行镜像</span>docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started<span class="hljs-comment">#等网页新增todo后，docker ps出来 rm -f掉，再启另外一个容器 发现数据还在</span>docker volume inspect todo-db<span class="hljs-comment">#操作网页的同时 发现_data文件变化</span>ll /var/lib/docker/volumes/todo-db/_data</code></pre><p><img src="Docker%E5%AD%A6%E4%B9%A05/image-20210914164030025.png" srcset="/img/loading.gif" alt="image-20210914164030025"></p><h3 id="使用挂载"><a href="#使用挂载" class="headerlink" title="使用挂载"></a>使用挂载</h3><p>如果我们只想存储数据，命名卷非常有用，因为我们不必担心数据存储在哪里。</p><p>快速卷类型比较 绑定挂载和命名卷是 Docker 引擎附带的两种主要类型的卷。但是，额外的卷驱动程序可用于支持其他用例（SFTP、Ceph、NetApp、S3 等）</p><table><thead><tr><th></th><th><strong>Named Volumes</strong></th><th><strong>Bind Mounts</strong></th></tr></thead><tbody><tr><td>Host Location</td><td>Docker默认</td><td>自己控制</td></tr><tr><td>挂载示例 (using <code>-v</code>)</td><td>my-volume:/usr/local/data</td><td>/path/to/data:/usr/local/data</td></tr><tr><td>容器内容填充volumes</td><td>支持</td><td>不支持</td></tr><tr><td>支持Volume驱动</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="启动开发模式容器"><a href="#启动开发模式容器" class="headerlink" title="启动开发模式容器"></a>启动开发模式容器</h3><pre><code class="hljs sh"> docker run -dp 3000:3000 \     -w /app -v <span class="hljs-string">"<span class="hljs-variable">$(pwd)</span>:/app"</span> \     node:12-alpine \     sh -c <span class="hljs-string">"yarn install &amp;&amp; yarn run dev"</span>     <span class="hljs-comment"># -w /app 设置“工作目录”或命令将运行的当前目录 </span><span class="hljs-comment"># -v "$(pwd):/app" 将容器中宿主机的当前目录绑定挂载到/app目录中</span><span class="hljs-comment"># node:12-alpine 使用的node环境镜像</span><span class="hljs-comment"># sh -c "yarn install &amp;&amp; yarn run dev"</span>docker ps<span class="hljs-comment">#查看该容器日志</span>docker logs -f &lt;container-id&gt;<span class="hljs-comment">#当修改src/static/js/app.js文件后 日志显示服务重启 刷新后页面更新</span><span class="hljs-comment">#开发机有docker情况下 无需配置环境 即可使用docker拉取开发环境</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习4</title>
    <link href="/2021/07/08/docker%E5%AD%A6%E4%B9%A04/"/>
    <url>/2021/07/08/docker%E5%AD%A6%E4%B9%A04/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习4"><a href="#Docker学习4" class="headerlink" title="Docker学习4"></a>Docker学习4</h1><h2 id="1-docker实战-构建简单应用"><a href="#1-docker实战-构建简单应用" class="headerlink" title="1.docker实战-构建简单应用"></a>1.docker实战-构建简单应用</h2><p>项目准备</p><p>按照官网简单的创建一个docker项目。项目地址：<a href="https://github.com/docker/getting-started/tree/master/app。" target="_blank" rel="noopener">https://github.com/docker/getting-started/tree/master/app。</a></p><p>在与package.json同级目录下创建一个Dockerfile文件（无后缀），编写如下代码（以后再解释）：</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">12</span>-alpine<span class="hljs-keyword">RUN</span><span class="bash"> apk add --no-cache python g++ make</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><span class="hljs-keyword">RUN</span><span class="bash"> yarn install --production</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"node"</span>,<span class="hljs-string">"src/index.js"</span>]</span></code></pre><p> 构建镜像</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -t tag 打上标签方便阅读</span>docker build -t getting-started .</code></pre><p>后台运行命令</p><pre><code class="hljs sh"><span class="hljs-comment"># -d 后台运行</span><span class="hljs-comment"># -p 端口映射</span>docker run -dp 3000:3000 getting-started</code></pre><p>此时访问localhost:3000(远程服务器自己换地址)就会出现如下页面：<img src="/image-20210907175412343.png" srcset="/img/loading.gif" alt="image-20210907175412343"></p><h2 id="2-更新项目"><a href="#2-更新项目" class="headerlink" title="2.更新项目"></a>2.更新项目</h2><p>在<code>src/static/js/app.js</code> 文件中,更新第56行。</p><pre><code class="hljs armasm">-                &lt;p className=<span class="hljs-string">"text-center"</span>&gt;No <span class="hljs-keyword">items </span>yet! <span class="hljs-keyword">Add </span>one above!&lt;/p&gt;+                &lt;p className=<span class="hljs-string">"text-center"</span>&gt;You have no todo <span class="hljs-keyword">items </span>yet! <span class="hljs-keyword">Add </span>one above!&lt;/p&gt;</code></pre><p>重新构建镜像后重启项目</p><pre><code class="hljs sh">docker build -t getting-started .docker run -dp 3000:3000 getting-started</code></pre><p>发现端口被占用</p><p><img src="/image-20210907180218103-16310089406632.png" srcset="/img/loading.gif" alt="image-20210907180218103"></p><pre><code class="hljs sh"><span class="hljs-comment"># 关闭之前的容器</span>docker ps<span class="hljs-comment"># 找到之前容器的容器ID</span>docker stop &lt;the-container-id&gt;<span class="hljs-comment"># 移除容器</span>docker rm &lt;the-container-id&gt;</code></pre><pre><code class="hljs angelscript">docker run -dp <span class="hljs-number">3000</span>:<span class="hljs-number">3000</span> getting-started</code></pre><p>此时访问localhost:3000(远程服务器自己换地址)就会出现如下页面：<img src="/image-20210907180946240.png" srcset="/img/loading.gif" alt="image-20210907180946240"></p><p>一个项目的docker构建就是这样了，如何交付呢？</p><h2 id="3-上传项目"><a href="#3-上传项目" class="headerlink" title="3.上传项目"></a>3.上传项目</h2><pre><code class="hljs sh"><span class="hljs-comment"># 登录自家的仓库地址 热心的运维会配置好这些基本环境（练习省略SERVER 默认使用官方仓库）</span>docker login SERVERdocker tag getting-started cuixiaotu/getting-starteddocker push cuixiaotu/getting-started</code></pre><p><img src="docker%E5%AD%A6%E4%B9%A04/image-20210914150054507.png" srcset="/img/loading.gif" alt="image-20210914150054507"></p><p>如此这般，在其他服务器上可以pull镜像下来，直接运行就可以了。</p><p>实际运用中CI 管道中很常见，管道将创建镜像并将其推送到仓库，然后生产/c测试环境可以使用最新版本的镜像。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习3</title>
    <link href="/2021/07/07/docker%E5%AD%A6%E4%B9%A03/"/>
    <url>/2021/07/07/docker%E5%AD%A6%E4%B9%A03/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习3"><a href="#Docker学习3" class="headerlink" title="Docker学习3"></a>Docker学习3</h1><h2 id="1-docker服务命令"><a href="#1-docker服务命令" class="headerlink" title="1.docker服务命令"></a>1.docker服务命令</h2><pre><code class="hljs sh"><span class="hljs-comment"># 启动docker</span>systemctl start docker <span class="hljs-comment"># 停止docker</span>systemctl stop docker <span class="hljs-comment"># 查看docker进程状态</span>systemctl status docker <span class="hljs-comment"># 重启docker</span>systemctl restart docker <span class="hljs-comment"># 开机重启docker</span>systemctl <span class="hljs-built_in">enable</span> docker</code></pre><h2 id="2-docker-镜像命令"><a href="#2-docker-镜像命令" class="headerlink" title="2.docker 镜像命令"></a>2.docker 镜像命令</h2><h3 id="2-1-查看镜像"><a href="#2-1-查看镜像" class="headerlink" title="2.1 查看镜像"></a>2.1 查看镜像</h3><pre><code class="hljs sh"><span class="hljs-comment"># 查看本地镜像</span>docker images<span class="hljs-comment"># 查看镜像详细情况</span>docker inspect ubuntu:18.04<span class="hljs-comment"># 查看镜像构建过程</span>docker <span class="hljs-built_in">history</span> ubuntu:18.04</code></pre><h3 id="2-2-搜索镜像"><a href="#2-2-搜索镜像" class="headerlink" title="2.2 搜索镜像"></a>2.2 搜索镜像</h3><pre><code class="hljs sh">docker search keyword--filter=is-official=<span class="hljs-literal">true</span> --filter=start=1000</code></pre><h3 id="2-3-搜索镜像"><a href="#2-3-搜索镜像" class="headerlink" title="2.3 搜索镜像"></a>2.3 搜索镜像</h3><pre><code class="hljs sh"><span class="hljs-comment"># 默认从Docker Hub镜像源下载镜像（配置加速地址） name镜像仓库名称  tag标签（不加会取lastest）</span>docker pull IMAGE[:TAG]docker pull ubantu:18.04<span class="hljs-comment"># 直接运行</span>docker run -it ubuntu:18.04</code></pre><h3 id="2-4-删除镜像"><a href="#2-4-删除镜像" class="headerlink" title="2.4 删除镜像"></a>2.4 删除镜像</h3><pre><code class="hljs sh">docker rmi IMAGE[:TAG]-f, -force：强制删除镜像，即使有容器依赖它-no-prune：不要清理未带标签的父镜像</code></pre><h2 id="3-docker-容器命令"><a href="#3-docker-容器命令" class="headerlink" title="3.docker 容器命令"></a>3.docker 容器命令</h2><h3 id="3-1-查看容器"><a href="#3-1-查看容器" class="headerlink" title="3.1 查看容器"></a>3.1 查看容器</h3><pre><code class="hljs sh"><span class="hljs-comment"># 查看正在运行的容器</span>docker ps<span class="hljs-comment"># 查看所有容器</span>docker ps -a</code></pre><h3 id="3-2-创建启动容器"><a href="#3-2-创建启动容器" class="headerlink" title="3.2 创建启动容器"></a>3.2 创建启动容器</h3><pre><code class="hljs sh">docker run -it IMAGE[:TAG] COMMAND-d 后台执行-i 保持一直运行-t 分配终端--name=<span class="hljs-string">''</span> 起名</code></pre><h3 id="3-3-进入容器"><a href="#3-3-进入容器" class="headerlink" title="3.3 进入容器"></a>3.3 进入容器</h3><pre><code class="hljs sh"><span class="hljs-comment"># 后台运行程序同s进入程序</span>docker <span class="hljs-built_in">exec</span> -it IMAGE[:TAG] COMMAND-d 后台执行-i 保持一直运行-t 分配终端--name=<span class="hljs-string">''</span> 起名<span class="hljs-comment"># 后台先运行程序 再进入程序</span>docker <span class="hljs-built_in">exec</span> -id IMAGE[:TAG]docker <span class="hljs-built_in">exec</span> -it name/IMAGE[:TAG] COMMAND</code></pre><h3 id="3-4-启动容器"><a href="#3-4-启动容器" class="headerlink" title="3.4 启动容器"></a>3.4 启动容器</h3><pre><code class="hljs sh">docker run 容器名/容器ID</code></pre><h3 id="3-5-删除容器"><a href="#3-5-删除容器" class="headerlink" title="3.5 删除容器"></a>3.5 删除容器</h3><pre><code class="hljs sh">docker rm 容器名/容器ID</code></pre><h3 id="3-6-查看容器详情"><a href="#3-6-查看容器详情" class="headerlink" title="3.6 查看容器详情"></a>3.6 查看容器详情</h3><pre><code class="hljs sh">docker inspect 容器名/容器ID</code></pre><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> -f, --filter filter：过滤输出内容；<span class="hljs-number">2.</span> --format <span class="hljs-built_in">string</span>：格式化输出内容；<span class="hljs-number">3.</span> --limit <span class="hljs-built_in">int</span>：限制输出结果个数，默认为<span class="hljs-number">25</span>个；<span class="hljs-number">4.</span> --no-trunc：不截断输出结果。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习2</title>
    <link href="/2021/07/06/docker%E5%AD%A6%E4%B9%A02/"/>
    <url>/2021/07/06/docker%E5%AD%A6%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习2"><a href="#Docker学习2" class="headerlink" title="Docker学习2"></a>Docker学习2</h1><h2 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1.docker安装"></a>1.docker安装</h2><h4 id="1-1-官方仓库安装"><a href="#1-1-官方仓库安装" class="headerlink" title="1.1 官方仓库安装"></a>1.1 官方仓库安装</h4><pre><code class="hljs sh"><span class="hljs-comment"># 官方推荐使用官方仓库安装 方便安装和更新docker</span><span class="hljs-comment"># 更新apt包  允许apt通过https使用stable仓库 </span><span class="hljs-comment"># 查看内核知道安装哪个版本</span>uname -a<span class="hljs-comment"># Linux cuixiaotu 5.4.0-77-generic #86-Ubuntu SMP Thu Jun 17 02:35:03 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span>cat /proc/version<span class="hljs-comment"># Linux version 5.4.0-77-generic (buildd@lgw01-amd64-028) (gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)) #86-Ubuntu SMP Thu Jun 17 02:35:03 UTC 2021</span>sudo apt-get updatesudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg \    lsb-release    <span class="hljs-comment"># 添加Docker官方GPG密钥    </span>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<span class="hljs-comment"># 获取当前操作系统代号</span>lsb_release -cs <span class="hljs-comment">#focal</span><span class="hljs-comment"># 以下命令设置stable仓库。 </span> <span class="hljs-built_in">echo</span> \  <span class="hljs-string">"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><span class="hljs-string">  <span class="hljs-variable">$(lsb_release -cs)</span> stable"</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null  sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre><h3 id="1-2-官方脚本安装"><a href="#1-2-官方脚本安装" class="headerlink" title="1.2 官方脚本安装"></a>1.2 官方脚本安装</h3><pre><code class="hljs sh">sudo curl -sSL https://get.docker.com | sh</code></pre><h2 id="2-安装后的配置"><a href="#2-安装后的配置" class="headerlink" title="2. 安装后的配置"></a>2. 安装后的配置</h2><p>Docker 守护进程绑定到 Unix 套接字而不是 TCP 端口。默认情况下，Unix 套接字由用户 root 拥有，其他用户只能使用 sudo 访问它。 Docker 守护进程始终以 root 用户身份运行。</p><p>如果不想在 docker 命令前加上 sudo，请创建一个名为 docker 的 Unix 组并向其中添加用户。当 Docker 守护进程启动时，它会创建一个可由 docker 组成员访问的 Unix 套接字</p><h3 id="2-1-配置Docker服务"><a href="#2-1-配置Docker服务" class="headerlink" title="2.1 配置Docker服务"></a>2.1 配置Docker服务</h3><p>为了避免每次使用Docker都需要切换身份，可以把当前用户添加到安装创建docker用户组</p><pre><code class="hljs sh"><span class="hljs-comment">#新增一个用户</span>adduser theodoresudo groupadd docker<span class="hljs-comment"># 由于linux用户权限是再用户登录的时候加载的  分配权限后需要退出再登录</span>sudo usermod -aG docker <span class="hljs-variable">$USER</span><span class="hljs-comment"># 可以用root账号把新用户添加到sudo组</span>usermod -aG sudo theodore<span class="hljs-comment"># linux权限在登录时验证缓存，新增f后需重新</span><span class="hljs-built_in">exit</span>docker -v<span class="hljs-comment">#Docker version 20.10.7, build f0df350</span>docker run hello-wored</code></pre><h3 id="2-2-配置镜像加速器"><a href="#2-2-配置镜像加速器" class="headerlink" title="2.2 配置镜像加速器"></a>2.2 配置镜像加速器</h3><p>这里使用阿里云镜像加速器，登录阿里云-容器镜像服务-镜像加速器可获取加速地址</p><pre><code class="hljs sh">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">'EOF'</span>&#123;  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://xxxxxx.mirror.aliyuncs.com"</span>]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h2 id="3-配置启动项"><a href="#3-配置启动项" class="headerlink" title="3.配置启动项"></a>3.配置启动项</h2><pre><code class="hljs sh"><span class="hljs-comment"># docker自启</span>sudo systemctl <span class="hljs-built_in">enable</span> docker.servicesudo systemctl <span class="hljs-built_in">enable</span> containerd.service</code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习1</title>
    <link href="/2021/07/05/docker%E5%AD%A6%E4%B9%A01/"/>
    <url>/2021/07/05/docker%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习1"><a href="#Docker学习1" class="headerlink" title="Docker学习1"></a>Docker学习1</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>由于之前主技术栈是PHP，对于代码发布部署，自研了一套集成gitlab的增量覆盖发布系统，自身对这一块确实不甚了解，当在新公司开始接触node，java项目，不得不开始面对Docker，当新技术兴起时，所有的技术人不能独善其身，都需永怀一颗学徒之心。</p><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><p><strong>Docker容器</strong>与虚拟机类似，但二者在原理上不同。容器是将<a href="https://zh.wikipedia.org/wiki/作業系統層虛擬化" target="_blank" rel="noopener">操作系统层虚拟化</a>，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。</p><h2 id="3-优势"><a href="#3-优势" class="headerlink" title="3.优势"></a>3.优势</h2><p>一次打包，到处运行。（怎么感觉和java一次编译，到处运行的概念一致，开发者无需关心底层物理硬件才是未来？）</p><ol><li><p>更快速的交付和部署</p></li><li><p>更高效的资源利用</p></li><li><p>更轻松的迁移和扩展</p></li><li><p>更简单的更新管理</p></li></ol><h2 id="4-架构"><a href="#4-架构" class="headerlink" title="4.架构"></a>4.架构</h2><p><img src="/architecture.svg" srcset="/img/loading.gif" alt="Docker 架构图"></p><h3 id="Docker-守护进程"><a href="#Docker-守护进程" class="headerlink" title="Docker 守护进程"></a>Docker 守护进程</h3><p>Docker 守护进程 ( <code>dockerd</code>) 侦听 Docker API 请求并管理 Docker 对象，例如镜像、容器、网络和卷。守护进程还可以与其他守护进程通信以管理 Docker 服务。</p><h3 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h3><p>Docker 客户端 ( <code>docker</code>) 是许多 Docker 用户与 Docker 交互的主要方式。当你使用类似<code>docker run</code>的命令时，客户端会将这些命令发送到<code>dockerd</code>，从而执行它们。该<code>docker</code>命令使用 Docker API。Docker 客户端可以与多个守护进程通信。</p><h3 id="Docker-镜像仓库"><a href="#Docker-镜像仓库" class="headerlink" title="Docker 镜像仓库"></a>Docker 镜像仓库</h3><p>Docker镜像仓库存储 Docker 镜像。Docker Hub 是一个任何人都可以使用的公共镜像库，Docker 默认配置为在 Docker Hub 上查找镜像。你也可以运行自己的私有仓库。</p><p>当你使用<code>docker pull</code>或<code>docker run</code>命令时，所需镜像将从你配置的镜像仓库中提取。当你使用该<code>docker push</code>命令时，你的镜像会被推送到你配置的仓库中。</p><h3 id="Docker-对象"><a href="#Docker-对象" class="headerlink" title="Docker 对象"></a>Docker 对象</h3><p>当你使用 Docker 时，你是在创建和使用镜像、容器、网络、卷、插件和其他对象。</p><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>一个镜像是用于创建一个docker容器指令的只读模板。一个镜像通常是基于额外定制化另一个镜像。例如，你可以基于<code>ubuntu</code> 镜像，构建一个 Apache Web 服务器和你的应用程序，以及应用程序运行所需的配置的一个镜像。</p><p>你可以创建自己的镜像，也可以仅使用其他人创建在共仓库中发布的镜像。要构建你自己的镜像，你使用简单的语法创建一个<em>Dockerfile</em>，用于定义创建镜像和运行镜像所需的步骤。Dockerfile 中的每条指令都会在镜像中创建一个层级。当你更改 Dockerfile 并重建镜像时，只会重建那些已更改的层。这就是与其他虚拟化技术相比，镜像更轻量、小巧和快速的部分原因。</p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是镜像的可运行实例。你可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。你可以将容器连接到一个或多个网络，为其附加存储，甚至可以根据其当前状态创建新镜像。</p><p>默认情况下，容器与其他容器和其主机相对隔离。你可以控制容器的网络、存储或其他底层子系统与其他容器或主机之间的隔离程度。</p><p>容器由其镜像以及你在创建或启动它时提供给它的任何配置选项定义。当容器被移除时，未存储到持久存储的任何状态上的更改都会消失。</p><h5 id="示例docker-run命令"><a href="#示例docker-run命令" class="headerlink" title="示例docker run命令"></a>示例<code>docker run</code>命令</h5><p>以下命令运行一个<code>ubuntu</code>容器，以交互方式附加到你的本地命令行会话，并运行<code>/bin/bash</code>.</p><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="bash"> -i -t ubuntu /bin/bash</span></code></pre><p>运行此命令时，会发生以下情况（假设你使用的是默认配置）：</p><ol><li>如果你在<code>ubuntu</code>本地没有该镜像，Docker 会从你配置的仓库中提取它，就像你<code>docker pull ubuntu</code>手动运行一样。</li><li>Docker 会创建一个新容器，就如同你手动运行命令<code>docker container create</code> 一样。</li><li>Docker 为容器分配一个读写文件系统，作为它的最后一层。这允许正在运行的容器在其本地文件系统中创建或修改文件和目录。</li><li>Docker 创建一个网络接口来连接容器和默认网络，因为你没有指定任何网络选项。这包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。</li><li>Docker 启动容器并执行<code>/bin/bash</code>. 由于容器以交互方式运行并附加到你的终端（由于<code>-i</code>和<code>-t</code> 标识），你可以在输出记录到终端时使用键盘提供输入。</li><li>当你键入<code>exit</code>以终止<code>/bin/bash</code>命令时，容器会停止但不会被移除。你可以重新启动它或将其删除。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB In-Memory Structures</title>
    <link href="/2021/04/21/mysql_01/"/>
    <url>/2021/04/21/mysql_01/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-InnoDB内存结构"><a href="#MySQL-InnoDB内存结构" class="headerlink" title="MySQL InnoDB内存结构"></a>MySQL InnoDB内存结构</h1><p>​    MySQL 5.5以后，InnoDB成为MySQL的默认存储引擎，随着MySQL远征八方。我们不该只知道行锁和事务特性，需细致一些。</p><p><img src="/../mysql_01/innodb-architecture.png" srcset="/img/loading.gif" alt="InnoDB architecture diagram showing in-memory and on-disk structures. In-memory structures include the buffer pool, adaptive hash index, change buffer, and log buffer. On-disk structures include tablespaces, redo logs, and doublewrite buffer files."></p><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p><img src="/../mysql_01/innodb-buffer-pool-list.png" srcset="/img/loading.gif" alt="Content is described in the surrounding text."></p><p>1.3/8属于老生代，5/8属于新生代。</p><p>2.midpoint位于新生代的尾部，新生代的头部</p><p>3.当InnoDB读取页到buffer pool时候，初始插到中点（既老生代的头部），页面对于有用户发起SQL或InnoDB预读机制。</p><p>4.访问老生代中的页会使之移动到新生代的头部，让它变年轻。如果是用户操作读取命中页，第一次访问则直接放在头部。</p><p>5.随着数据库的运行，缓冲池中未被访问的页将“老化” ,移至列表的末尾。新生代和老生代中的页都会随着其他页的更新而老化。随着将页插入midpoint，老生代的页也会老化。最终，未使用的页到达老生代的尾部并被逐出。</p><p> innodb_old_blocks_pct   老生代块比例</p><p> innodb_old_blocks_time 老生代块时间（放入老生代多久后命中操作才会放入新生代）</p><h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h3><p>change buffer是一种特殊的数据结构，用于在二级索引页不在缓冲池中时将更改缓存到二级索引页。可能由INSERT，UPDATE或DELETE操作（DML）导致的缓冲更改将在以后通过其他读取操作将页面加载到缓冲池中时合并。</p><p><img src="/../gitlab-runner/innodb-change-buffer.png" srcset="/img/loading.gif" alt="Content is described in the surrounding text."></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA成神之路二</title>
    <link href="/2021/03/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%BA%8C/"/>
    <url>/2021/03/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA成神之路二"><a href="#JAVA成神之路二" class="headerlink" title="JAVA成神之路二"></a>JAVA成神之路二</h1><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><h3 id="什么是面对对象"><a href="#什么是面对对象" class="headerlink" title="什么是面对对象"></a>什么是面对对象</h3><p>类是构造对象的模板或蓝图。</p><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h3><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p><p>类与对象</p><p>雇员示例</p><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> LocalDate hireDay;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n,<span class="hljs-keyword">double</span> s,<span class="hljs-keyword">int</span> year,<span class="hljs-keyword">int</span> month,<span class="hljs-keyword">int</span> day)</span></span>&#123;        name = n;        salary = s;        hireDay = LocalDate.of(year,month,day);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> salary;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> hireDay;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPrecent)</span></span>&#123;        <span class="hljs-keyword">double</span> raise = salary * byPrecent / <span class="hljs-number">100</span>;        salary += raise;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Employee[] staff = <span class="hljs-keyword">new</span> Employee[<span class="hljs-number">3</span>];        staff[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"carl craker"</span>,<span class="hljs-number">75000</span>,<span class="hljs-number">2020</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span>);        staff[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"harry hacker"</span>,<span class="hljs-number">45000</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>);        staff[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"tony tester"</span>,<span class="hljs-number">35000</span>,<span class="hljs-number">2021</span>,<span class="hljs-number">3</span>,<span class="hljs-number">13</span>);        <span class="hljs-keyword">for</span> (Employee e : staff)&#123;            e.raiseSalary(<span class="hljs-number">5</span>);        &#125;        <span class="hljs-keyword">for</span> (Employee e : staff)&#123;            System.out.println(<span class="hljs-string">"name="</span> + e.getName()+<span class="hljs-string">",salary="</span>+e.getSalary() + <span class="hljs-string">",hireday="</span>+e.getHireDay() );        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>端对端加密</title>
    <link href="/2021/02/20/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E5%8A%A0%E5%AF%86/"/>
    <url>/2021/02/20/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="端对端加密"><a href="#端对端加密" class="headerlink" title="端对端加密"></a>端对端加密</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><blockquote><p>End-to-end encryption (E2EE) is a system of communication where only the communicating users can read the messages. In principle, it prevents potential eavesdroppers – including telecom providers, Internet providers, and even the provider of the communication<br>service – from being able to access the cryptographic keys needed to decrypt the conversation.</p><p>端到端加密（E2EE）是一种通信系统，其中只有进行通信的用户才能阅读消息。原则上，它可以防止潜在的窃听者（包括电信提供商，Internet提供商，甚至通信提供商服务）能够访问解密对话所需的加密密钥。</p><p>The term “end-to-end encryption” originally only meant that the communication is never decrypted during its transport from the sender to the receiver.For example, around 2003, E2EE has been proposed as an additional layer of encryption for <a href="https://en.wikipedia.org/wiki/GSM" target="_blank" rel="noopener">GSM</a> or <a href="https://en.wikipedia.org/wiki/Terrestrial_Trunked_Radio" target="_blank" rel="noopener">TETRA</a>,in addition to the existing radio encryption protecting the communication between the mobile device and the network infrastructure. This has been standardised by SFPG for TETRA.Note that in TETRA E2EE, the keys are generated by a Key Management Centre (KMC) or a Key Management Facility (KMF), not by the communicating users.</p><p>Later, around 2014, the meaning of “end-to-end encryption” started to evolve requiring that not only the communication stays encrypted during transport, but also that the provider of the communication service is not able to decrypt the communications either by having access to the private key, or by having the capability to undetectably inject an adversarial public key as part of a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">man-in-the-middle attack</a>. This new meaning is now the widely accepted one.</p><p>“端到端加密”最初仅表示通信从发送方到接收方的传输过程中永远不会解密。 例如，2003年左右，E2EE已经被提出作为加密额外层<a href="https://en.wikipedia.org/wiki/GSM" target="_blank" rel="noopener">GSM </a>或<a href="https://en.wikipedia.org/wiki/Terrestrial_Trunked_Radio" target="_blank" rel="noopener">TETRA</a>，在除了现有的无线电加密保护移动设备和网络基础设施之间的通信。SFPG已将其标准化为TETRA。请注意，在TETRA E2EE中，密钥是由密钥管理中心（KMC）或密钥管理工具（KMF）生成的，而不是由通信用户生成的。</p><p>后来，大约在2014年，“端到端加密”的含义开始发展，不仅要求通信在传输过程中保持加密，而且通信服务的提供者必须不能够解密通信无论是其访问私有密钥，或有注射对抗性公共密钥的能力，无法检测作为一部分中间人攻击。现在，这一新含义已被广泛接受。</p><p>[*<a href="https://en.wikipedia.org/wiki/End-to-end_encryption" target="_blank" rel="noopener">摘自维基百科</a>*]</p></blockquote><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h2><p>人生而自由，隐私和安全性存在于我们的DNA中，这就是我们在应用程序中内置端到端加密的原因。端到端加密后，您的消息，照片，视频，语音消息，文档，状态更新和呼叫就可以避免落入错误的人手中。</p><h2 id="3-方案"><a href="#3-方案" class="headerlink" title="3.方案"></a>3.方案</h2><h3 id="3-1-RocketChat"><a href="#3-1-RocketChat" class="headerlink" title="3.1 RocketChat"></a>3.1 RocketChat</h3><p>rocketChat的端对端加密还在测试阶段，并不影响我们对其的学习。整理的流程图如下：</p><p>1.客户端生成随机密码，用于sha256后生成主密钥</p><p>2.客户端生成密钥对，私钥通过主密钥加密后，保存公钥和加密后的私钥到用户表</p><p>3.客户端开启端对端加密会话,根据当前会话生成会话密钥，会话密钥经私钥加密后存储在订阅表中</p><p>4.来往消息加解密都是通过经过本地解密后的会话密钥</p><p><img src="rocket-chat-e2ee.png" srcset="/img/loading.gif" alt=""></p><p>优点：</p><p>1.官方源码支持</p><p>2.支持群聊</p><p>3.兼容性强，之前的未加密会话可以无缝切换成加密会话</p><p>缺点：</p><p>1.官方方案还在Beta期</p><p>2.搜索操作将找不到加密房间的加密消息</p><h3 id="3-2-telegram"><a href="#3-2-telegram" class="headerlink" title="3.2 telegram"></a>3.2 telegram</h3><p>telegram的加密基于Diffie Hellman算法，确保共享key穿越不安全的方法。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>类比:Alice和Bob公开使用黄色的画布，两人选择各自的秘密颜色保留，Alice选择红色，Bob选择蓝绿色。两人将黄色和各自秘密颜色混色，变为棕黄色和浅蓝色，然后公开两种混色。最后双方拿到对方的混合色和自己的秘密颜色混合，最终形成一致的配色。</p><p>实际使用的很大的数字和整数模p的乘法组让超级计算机也没办法短时间内计算出密钥。其他实现算法椭圆曲线和</p><p><img src="color.jpg" srcset="/img/loading.gif" alt="img"></p><p>生成会话密钥</p><p>1.Alice开启和Bob的加密会话，生素数p和高阶元素g</p><p>2.客户端检查p是否为2048位的素数，且g为循环子组素数阶数(p-1)/2.由于g始终等于2,3,4,5,6,7,很容易完成二次互易定理。</p><p>3.Alice 生成随机的a和计算<code>g_a := pow(g, a) mod dh_prime</code></p><p>4.Bob接收Alice的基本信息和DH生成的最新参数配置，自身生成一个随机数b</p><p>5.Bob生成最终共享密钥 <code>key = (pow(g_a, b) mod dh_prime)</code></p><p>6.Bob返回给Alice<code>g_b := pow(g, b) mod dh_prime</code></p><p>7.Alice接收g_b，并可以得出<code>key = (pow(g_b, a) mod dh_prime)</code></p><p><img src="telegram.png" srcset="/img/loading.gif" alt=""></p><p>优点：</p><p>1.采用Diffie-Hellman加密方式</p><p>2.完善的前向保密</p><p>3.加密维度 消息级</p><p>缺点：</p><p>1.计算密集</p><p>2.不支持群聊</p><h3 id="3-3-WhatsApp"><a href="#3-3-WhatsApp" class="headerlink" title="3.3 WhatsApp"></a>3.3 WhatsApp</h3><p>基于Signal Protocol 协议</p><p><img src="lun.png" srcset="/img/loading.gif" alt="img"></p><p>棘轮为单向转动的特殊齿轮，即算法不断的生成新的Message Key用于加密消息，且即使破解某一个Message Key只能破解单条消息，也无法破解之前消息。</p><p>1.用户注册时候生成Identity Key Pair,Signed Pre Key 和One-Time Pre Keys，传输给服务端并储存到用户表。</p><ul><li>Identity Key Pair：身份密钥对，安装时生成的长期Curve25519密钥对</li><li>Signed Pre Key：签名预密钥，安装时生成的中期Curve255129密钥对</li><li>One-Time Pre Keys：一次性预密钥，用于加密消息的80位值，32位用于AES-256密钥，32位用于HMAC-SHA256,16位用于IV</li></ul><p>2.创建一个加密会话，（除非重装APP或更换设备），则无需重建会话。</p><p> （为了区分发信人和收信人，认识两位老同学Alice和Bob）</p><ul><li><p>Alice请求Bob的Identity Key，Signed Pre Key，和一个One-Time Pre Key。</p></li><li><p>服务端返回公共keys。One-Time Pre Key一旦返回则在服务端删除，若没有了且未补充生成，则不返回One-Time Pre Key。</p></li><li><p>Alice接收Bob的Identity Key为<code>I recipient</code>，Signed Pre Key为<code>S recipient</code>，One-Time Pre Key为<code>O recipient</code>。</p></li><li><p>Alice生成短暂的密钥对Curve25519,<code>E initiator。</code></p></li><li><p>Alice把自己的Identity Key当<code>I initiator</code>。</p></li><li><p>Alice计算主密钥：(如果没有One-Time Pre Keys了最后的ECDH被忽略)</p><pre><code class="hljs reasonml">master_secret = <span class="hljs-constructor">ECDH(I <span class="hljs-params">initiator</span>,S <span class="hljs-params">recipient</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">ECDH(E <span class="hljs-params">initiator</span>,I <span class="hljs-params">recipient</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">ECDH(E <span class="hljs-params">initiator</span>,S <span class="hljs-params">recipient</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">ECDH(E <span class="hljs-params">initiator</span>,O <span class="hljs-params">recipient</span>)</span></code></pre></li><li><p>Alice用主密钥创建Root Key和Chain Key。</p></li></ul><p>3.会话创建后，客户端使用AES256_CBC加密和HMAC-SHA256验证消息。Message Key随着每个消息短暂存在且变化，并且在发送或接收消息后无法重建，解密Message Key由Alice的Chain Key发送的每一条消息生成。</p><p>4.Bob收到消息后，使用Alice公钥和自己的密钥，计算出master_secret，从而得到当前消息的Message Key。</p><p>5.Bob和Alice使用Message Key进行加密通信。</p><p>优点：</p><p>1.安全系数高</p><p>2.支持加密各种附件，语音视频，群组</p><p>3.完善的前向保密</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p>1.<a href="https://scontent.whatsapp.net/v/t39.8562-34/122249142_469857720642275_2152527586907531259_n.pdf/WA_Security_WhitePaper.pdf?ccb=3&_nc_sid=2fbf2a&_nc_ohc=AKi8-7dPSA4AX9DqpdV&_nc_ht=scontent.whatsapp.net&oh=dfa7bc578cf584b3c21644e79dce60d0&oe=60663219" target="_blank" rel="noopener">WhatsApp白皮书 </a></p><p>2.<a href="https://docs.rocket.chat/guides/security/end-to-end-encryption-algorithms" target="_blank" rel="noopener">rocketchat官方文档</a></p><p>3.<a href="https://core.telegram.org/api/end-to-end" target="_blank" rel="noopener">telegram官方文档</a>     </p>]]></content>
    
    
    <categories>
      
      <category>IM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA成神之路一</title>
    <link href="/2020/09/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B8%80/"/>
    <url>/2020/09/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA成神之路一"><a href="#JAVA成神之路一" class="headerlink" title="JAVA成神之路一"></a>JAVA成神之路一</h1><h2 id="1-安装部署"><a href="#1-安装部署" class="headerlink" title="1.安装部署"></a>1.安装部署</h2><p>​    </p><ol><li><p>linux部署 还是得用openJava 其中阿里的开源dragonwell不错</p><pre><code class="hljs vim">wget http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/alibaba/dragonwell8/releases/download/dragonwell-<span class="hljs-number">8.5</span>.<span class="hljs-number">5</span>_jdk8u275-ga/Alibaba_Dragonwell_8.<span class="hljs-number">5.5</span>-GA_Linux_x64.tar.gztar xf Alibaba_Dragonwell_8.<span class="hljs-number">5.5</span>-GA_Linux_x64.tar.gz -C /<span class="hljs-keyword">opt</span>JAVA_HOME=/<span class="hljs-keyword">opt</span>/jdk8u275-b1/PATH=SPATH:$JAVA_HOME/binjava -<span class="hljs-keyword">version</span>// 持久化<span class="hljs-keyword">cat</span> &gt;&gt; ~/.bashrc</code></pre></li><li><p>window环境 只是开发的话 建议去官网直接下载<br><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p></li></ol><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h3><p>整型</p><table><thead><tr><th>数据类型</th><th>存储</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1字节</td><td>-128(-2^7)到127(2^7-1)</td><td>0</td></tr><tr><td>short</td><td>2字节</td><td>-32,768 (-2^15)到32,767 (2^15-1)</td><td>0</td></tr><tr><td>int</td><td>4字节</td><td>-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)</td><td>0</td></tr><tr><td>long</td><td>8字节</td><td>-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)</td><td>0l</td></tr></tbody></table><p>浮点 float double</p><table><thead><tr><th>数据类型</th><th>存储</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>1.4E-45 （2^-149）到（2^128-1）</td><td>2.15F</td></tr><tr><td>double8</td><td>8字节</td><td>4.9E-324 （2^-1074）到1.7976931348623157E308 （2^1024-1）</td><td>3.12D</td></tr></tbody></table><p>布尔 boolean</p><p>​    false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换</p><p>字符 char</p><p>​    char类型描述了UTF-16编码中的一个代码单元,可以和int类型互换，对应维护的字符表。</p><h3 id="2-2-自动拆装箱"><a href="#2-2-自动拆装箱" class="headerlink" title="2.2 自动拆装箱"></a>2.2 自动拆装箱</h3><p>Java 语言是一个面向对象的语言，但是 Java 中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便（集合类中），为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p><p>自动装箱: 就是将基本数据类型自动转换成对应的包装类。<br>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p><p>包装类均位于 <code>java.lang</code> 包，包装类和基本数据类型的对应关系如下表所示</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="2-3-字符串-String"><a href="#2-3-字符串-String" class="headerlink" title="2.3  字符串 String"></a>2.3  字符串 String</h3><p>字符串就是Unicode字符序列，一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。如果你需要一个可修改的字符串，应该使用StringBuffer 或者 StringBuilder。否则会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的string对象被创建出来。</p><h4 id="2-3-1-字符串的截取"><a href="#2-3-1-字符串的截取" class="headerlink" title="2.3.1 字符串的截取"></a>2.3.1 字符串的截取</h4><p>substring 截取字符串并返回其[beginIndex,endIndex-1]范围内的内容，会创建一个全新的string对象。</p><h4 id="2-3-2-字符串的拼接"><a href="#2-3-2-字符串的拼接" class="headerlink" title="2.3.2 字符串的拼接"></a>2.3.2 字符串的拼接</h4><p>concat              创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个                          新的String对象并返回</p><p>+                          Java提供的一个语法糖,其实现原理是使用<code>StringBuilder.append</code></p><p>StringBuilder     字符数组不是用final形容，可以修改，在拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p><p>StringBuffer       在StringBuilder的基础上，用synchronized描述append,线程安全的</p><p>StringUtils.concat  也是通过<code>StringBuilder</code>来实现的</p><pre><code class="hljs autohotkey">性能耗时`StringBuilder`&lt;`StringBuffer`&lt;`concat`&lt;`+`&lt;`StringUtils.join</code></pre><h4 id="2-3-3-字符串的替换"><a href="#2-3-3-字符串的替换" class="headerlink" title="2.3.3 字符串的替换"></a>2.3.3 字符串的替换</h4><p>replace(CharSequence target, CharSequence replacement) ，用replacement替换所有的target，两个参数都是字符串。</p><p>replaceAll(String regex, String replacement) ，用replacement替换所有的regex匹配项，regex很明显是个正则表达式，replacement是字符串。</p><p>replaceFirst(String regex, String replacement) ，基本和replaceAll相同，区别是只替换第一个匹配项。</p><h4 id="2-3-4-字符串常量池"><a href="#2-3-4-字符串常量池" class="headerlink" title="2.3.4 字符串常量池"></a>2.3.4 字符串常量池</h4><pre><code class="hljs java">String str = <span class="hljs-string">"theodore"</span>;String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"theodore"</span>);</code></pre><p>第一种 JVM为了减少相同字符串的重复创建，会单独开辟一块内存空间，用于保存字符串常量，这个内存区域被叫做字符串常量池。</p><p>当代码直接用双引号（字面量）创建字符串对象时，JVM会对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象引用，则直接返回该引用。否则创建新的字符串对象，然后这个引用放入字符串常量池，并返回该引用。</p><p>（JDK7 之前，字符串常量池放在永久代中，JDK7放在堆内空间，JDK8引入元空间，重新放回永久代）</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 数据结构</title>
    <link href="/2020/08/20/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/08/20/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h1><p>最近又重新看了一遍Redis 整理一下阅读笔记</p><h2 id="1-redis支持的数据结构"><a href="#1-redis支持的数据结构" class="headerlink" title="1.redis支持的数据结构"></a>1.redis支持的数据结构</h2><p>字符串，哈希，列表，集合，有序集合<br>string，hash,list,set,sorted set</p><h2 id="2-redis内部的数据结构"><a href="#2-redis内部的数据结构" class="headerlink" title="2.redis内部的数据结构"></a>2.redis内部的数据结构</h2><p>简单动态字符串<br>双向链表<br>压缩链表<br>哈希表<br>跳表<br>整数数组</p><h2 id="3-数据结构关系如下"><a href="#3-数据结构关系如下" class="headerlink" title="3.数据结构关系如下"></a>3.数据结构关系如下</h2><p><img src="redis01_0.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="4-内部数据结构介绍"><a href="#4-内部数据结构介绍" class="headerlink" title="4.内部数据结构介绍"></a>4.内部数据结构介绍</h2><h3 id="4-1-简单动态字符串"><a href="#4-1-简单动态字符串" class="headerlink" title="4.1 简单动态字符串"></a>4.1 简单动态字符串</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span>    <span class="hljs-comment">//记录buf数组中已使用字节的数量</span>    <span class="hljs-comment">//等于SDS所保存字符串的长度</span>    <span class="hljs-keyword">int</span> len;    <span class="hljs-comment">//记录buf数组中未使用字节的数量</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span>;    <span class="hljs-comment">//字节数组，用于保存字符串</span>    <span class="hljs-keyword">char</span> buf[];&#125;;</code></pre><p>len: 以O(1)时间复杂度获取长度<br>free:  避免缓冲区溢出  减少字符串修改时的空间重分配次数 (C的空间操作真的要小心翼翼)<br>二进制安全 以编码和<br>同样以\0空字符结尾(不记录与长度中，真实长度会比len大1)<br>兼容部分C字符串的长度</p><h3 id="4-2-双向链表"><a href="#4-2-双向链表" class="headerlink" title="4.2 双向链表"></a>4.2 双向链表</h3><pre><code class="hljs cpp">#链表节点<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span>    <span class="hljs-comment">// 前置节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">prev</span>;</span>    <span class="hljs-comment">// 后置节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//节点的值</span>    <span class="hljs-keyword">void</span> * value;&#125;listNode;#链表<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span>    <span class="hljs-comment">//</span>    表头节点    listNode * head;    <span class="hljs-comment">//</span>    表尾节点    listNode * tail;    <span class="hljs-comment">//</span>    链表所包含的节点数量    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;    <span class="hljs-comment">//</span>    节点值复制函数    <span class="hljs-keyword">void</span> *(*dup)(<span class="hljs-keyword">void</span> *ptr);    <span class="hljs-comment">//</span>    节点值释放函数    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-keyword">void</span> *ptr);    <span class="hljs-comment">//</span>    节点值对比函数    <span class="hljs-keyword">int</span> (*match)(<span class="hljs-keyword">void</span> *ptr,<span class="hljs-keyword">void</span> *key);&#125; <span class="hljs-built_in">list</span>;</code></pre><p>双端： 获取prev和next时间复杂度都为O(1)<br>无环： 头Node的prev和尾Node的next都指向Null<br>dup，free，match 实现多态链表的特定函数</p><h3 id="4-3-哈希表（字典）"><a href="#4-3-哈希表（字典）" class="headerlink" title="4.3 哈希表（字典）"></a>4.3 哈希表（字典）</h3><pre><code class="hljs arduino"><span class="hljs-comment">//哈希表</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span>    <span class="hljs-comment">//哈希表数组</span>    dictEntry **table;    <span class="hljs-comment">//哈希表大小</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-built_in">size</span>;    <span class="hljs-comment">//哈希表大小掩码，用于计算索引值</span>    <span class="hljs-comment">//总是等于size-1</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;    <span class="hljs-comment">//该哈希表已有节点的数量</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;&#125; dictht;<span class="hljs-comment">//哈希表节点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span>    <span class="hljs-comment">//键</span>    <span class="hljs-keyword">void</span> *key;    <span class="hljs-comment">//值</span>    <span class="hljs-keyword">union</span>&#123;        <span class="hljs-keyword">void</span> *val;        uint64_tu64;        int64_ts64;    &#125; v;    <span class="hljs-comment">//指向下个哈希表节点，形成链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span>&#125; dictEntry;<span class="hljs-comment">//字典</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span>    <span class="hljs-comment">//类型特定函数</span>    dictType *type;    <span class="hljs-comment">//私有数据</span>    <span class="hljs-keyword">void</span> *privdata;    <span class="hljs-comment">//哈希表</span>    dictht ht[<span class="hljs-number">2</span>];    <span class="hljs-comment">// rehash索引</span>    <span class="hljs-comment">//当rehash不在进行时，值为-1</span>    in trehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span>&#125; dict;<span class="hljs-comment">//字典类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span>    <span class="hljs-comment">//计算哈希值的函数</span>    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-params">(*hashFunction)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key)</span></span>;    <span class="hljs-comment">//复制键的函数</span>    <span class="hljs-keyword">void</span> *(*keyDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);    <span class="hljs-comment">//复制值的函数</span>    <span class="hljs-keyword">void</span> *(*valDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj);    <span class="hljs-comment">//对比键的函数</span>    <span class="hljs-keyword">int</span> (*keyCompare)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key2);    <span class="hljs-comment">//销毁键的函数</span>    <span class="hljs-keyword">void</span> (*keyDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *key);    <span class="hljs-comment">//销毁值的函数</span>    <span class="hljs-keyword">void</span> (*valDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *obj);&#125; dictType;</code></pre><p>哈希算法 ： 把一对键值对存到字典中，先回对键进行计算出哈希值和索引值，然后根据索引值把哈希表节点放到哈希表数组指定的位置上。<br>哈希冲突 ： 众所周知，拉链法和直线寻址法。直线寻址会过多分配空间且不好维护，拉链法在命中同一哈希key太多时，性能下降。redis的解决方案，拉链法和rehash。<br>rehash ：<br>触发条件<br>load_factor = ht[0].used / ht[0].size ;<br>当服务器未进行BGSAVE和BGREWRITEAOF 且load_factor大于等于1<br>当服务器在执行BGSAVE和BGREWRITEAOF 且load_factor大于等于5<br>缩容 load_factor则小于等于0.1<br>行为</p><p>1) 给字典中的ht[1]分配空间，扩容为ht[0].used*2n 缩容为ht[0].used/2n<br>2) 将保存在ht[0]中的所有键值对重新计算哈希值和索引值，然后把键值对放置到ht[1]哈希表制定位置上<br>3) 迁移完成后，释放ht[0],将ht[1]设置为ht[0]，为ht[1]新创建个空白哈希表<br>思考问题：<br>1.哈希表过大时迁移是否太耗资源，堵塞其他操作<br> 渐进式rehash 通过rehashidx索引计数器逐步迁移<br>2.rehash过程中的增删改查，是如何操作的<br>  增 只操作ht[1]<br>  删 改 查  会操作两个哈希表</p><h3 id="4-4-跳表"><a href="#4-4-跳表" class="headerlink" title="4.4 跳表"></a>4.4 跳表</h3><pre><code class="hljs cpp"><span class="hljs-comment">//跳表节点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span>    <span class="hljs-comment">//层</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span>        <span class="hljs-comment">//前进指针</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span>        <span class="hljs-comment">//跨度</span>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> span;    &#125; level[];    <span class="hljs-comment">//后退指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span>    <span class="hljs-comment">//分值</span>    <span class="hljs-keyword">double</span> score;    <span class="hljs-comment">//成员对象</span>    robj *obj;&#125; zskiplistNode;<span class="hljs-comment">//跳表</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span>    <span class="hljs-comment">//表头节点和表尾节点</span>    structz skiplistNode *header, *tail;    <span class="hljs-comment">//表中节点的数量</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;    <span class="hljs-comment">//表中层数最大的节点的层数</span>    <span class="hljs-keyword">int</span> level;&#125; zskiplist;</code></pre><p>用于有序集合或集群节点中</p><h3 id="4-5-整数集合"><a href="#4-5-整数集合" class="headerlink" title="4.5 整数集合"></a>4.5 整数集合</h3><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> struct <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span> &#123;    <span class="hljs-comment">//编码方式</span>    <span class="hljs-built_in">uint</span>32_t encoding;    <span class="hljs-comment">//集合包含的元素数量</span>    <span class="hljs-built_in">uint</span>32_t length;    <span class="hljs-comment">//保存元素的数组</span>    <span class="hljs-built_in">int</span>8_t contents[];&#125; <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span>;</code></pre><p>升级</p><p>1) 根据新元素的类型 扩展整数集合底层数组空间大小 并为新元素分配空间<br>2) 将底层数组所有的元素转换为新元素类型 将类型转换后的元素放到正确的位置上去<br>3) 将新元素添加按到底层数组里</p><p>降级<br>不支持降级，故升级后的编码 即使大元素被删 也不会恢复为之前的编码</p><h3 id="4-6-压缩列表"><a href="#4-6-压缩列表" class="headerlink" title="4.6 压缩列表"></a>4.6 压缩列表</h3><p><img src="redis01_1.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="redis01_2.jpg" srcset="/img/loading.gif" alt=""></p><p>压缩列表是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结枃。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值  </p><p>参考: </p><ul><li>Redis官方文档 </li><li>Redis设计与实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2020/07/17/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2020/07/17/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>有序数组查找<br>有序数组的查找使用二分查找可以减少比较次数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rank</span><span class="hljs-params">(Key key)</span></span>&#123;    <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = N -<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (lo &lt;= hi)&#123;        <span class="hljs-keyword">int</span> mid = (hi-lo)/<span class="hljs-number">2</span> + lo;        <span class="hljs-keyword">int</span> cmp = key.compareTo(keys[mid]);        <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) hi =mid-<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) lo = mid +<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;    &#125;    <span class="hljs-keyword">return</span> lo;&#125;</code></pre><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>在树的任意一个节点，其左子树的每个节点的值都要小于这个节点的值，而右子树节点的值都要大于这个节点的值。（基于二分查找，满二叉查找数）</p><p><img src="binary_search_tree.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;  <span class="hljs-keyword">private</span> Node tree;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    Node p = tree;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node left;    <span class="hljs-keyword">private</span> Node right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;    tree = <span class="hljs-keyword">new</span> Node(data);    <span class="hljs-keyword">return</span>;  &#125;  Node p = tree;  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;        p.right = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.right;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;        p.left = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.left;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span>  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;    pp = p;    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;    <span class="hljs-keyword">else</span> p = p.left;  &#125;  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>  <span class="hljs-comment">// 要删除的节点有两个子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>    Node minP = p.right;    Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span>    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;      minPP = minP;      minP = minP.left;    &#125;    p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span>    p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span>    pp = minPP;  &#125;  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>  Node child; <span class="hljs-comment">// p的子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;  <span class="hljs-keyword">else</span> pp.right = child;&#125;</code></pre><table><thead><tr><th>算法</th><th align="center">查找</th><th align="right">插入</th></tr></thead><tbody><tr><td>顺序查询</td><td align="center">N/2</td><td align="right">N</td></tr><tr><td>二分查找</td><td align="center">lgN</td><td align="right">N/2</td></tr><tr><td>二叉树查找</td><td align="center">lgN</td><td align="right">lgN</td></tr></tbody></table><p>二叉查找树平均情况下 性能还是不错的，但是在增删的情况下，无法保持平衡，最终可能退化为链表导致性能大幅度下降。</p><h2 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h2><p>2-3查找树 ： 一棵空树或由2-结点和3-结点组成的树<br>2-结点：含一个键和两个链接，左链接指向的2-3树中的结点都小于该结点，右链接指向的2-3树中的结点都大于该结点s<br>3-结点：含两个键和三个链接，左链接指向的2-3树中的结点都小于该结点，右链接指向的2-3树中的结点都大于该结点，中结点指向的结点的键位于该结点两个键的中间</p><p><img src="2-3_tree.png" srcset="/img/loading.gif" alt=""></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从根节点开始，若和节点中的</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>1） 如果是空树，创建一个节点并存入值<br>2） 否则找到叶子节点<br>3） 如果叶子节点只有一个值，新值也存入该节点<br>4） 如果叶子节点超过两个值，分离该节点，并把三个值的中位值提升至父节点<br>5） 如果父节点有三个值，继续4的操作 直至根节点</p><pre><code class="hljs java"></code></pre><h2 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h2><p>1) 根节点是黑色的<br>2) 每个节点非黑既红<br>2) 每个叶子节点都是黑色的空节点（nil）<br>3) 任何相邻的节点都不能同时为红色<br>4) 每个节点 到达其可达的叶子节点的所有路径都包含相同数目的黑色节点</p><p><img src="red_black_tree.png" srcset="/img/loading.gif" alt=""></p><p>（可以结合上面的2-3图一起看哟 画图不易）</p><p>旋转还是挺复杂的 有空再来慢慢画图和编码 留一个坑在这里 </p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Just Sort</title>
    <link href="/2020/07/04/just-sort/"/>
    <url>/2020/07/04/just-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="排序大全"><a href="#排序大全" class="headerlink" title="排序大全"></a>排序大全</h1><p>排序是将一组对象按照某种逻辑顺序重新排列的过程。<br>每次都草草的看下排序似懂非懂，知其然不知其所以然,这次用go简单的实现一下。</p><hr><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>思路:两两比较 轻的上浮 重的下沉</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bubble</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123; <span class="hljs-comment">//n次是必须的</span>        <span class="hljs-comment">//优化思路 每次比较完 最重的已经沉到底了（多减1 是两两比较的原因）</span>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; j++ &#123;            <span class="hljs-keyword">if</span> less(comparable[j+<span class="hljs-number">1</span>], comparable[j]) &#123;                exchange(comparable, j, j+<span class="hljs-number">1</span>)            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>思路:每次选出最小值放在将它和数组的第一个元素交换位置，再在剩余的元素中反复操作</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Selection</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123; <span class="hljs-comment">//进行N次变换</span>        min := i <span class="hljs-comment">//每次重置最小值为开始值</span>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;            <span class="hljs-keyword">if</span> less(comparable[j], comparable[min]) &#123;                min = j            &#125;        &#125;        exchange(comparable, i, min)    &#125;&#125;</code></pre><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>思路：按照理牌的思路 每来一张牌 把牌放在已经排序好的合适位置</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Insertion</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;        k := i <span class="hljs-comment">//拿到第i张牌的时候</span>        <span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">//嘿嘿 这里用的算法导论里的while 大家用for一个原理</span>            <span class="hljs-comment">//只有一张牌|当前牌重置到第一张|当前牌到了合适位置 从右向左移动</span>            <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-number">0</span> || less(comparable[k<span class="hljs-number">-1</span>], comparable[k]) &#123;                <span class="hljs-keyword">break</span>            &#125;            exchange(comparable, k, k<span class="hljs-number">-1</span>)            k-- <span class="hljs-comment">//当然 每次交换位置后 k减1</span>        &#125;    &#125;&#125;</code></pre><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>思路:插入排序的优化 前面的排序只会交换相邻位置  希尔交换不相邻元素对数组局部进行排序<br>使数组中间隔为h的元素都是有序的 h按一定规律（未有最优递增序列）递减</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Shell</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    h := <span class="hljs-number">1</span>    <span class="hljs-comment">//设置步长 (递增序列)</span>    <span class="hljs-keyword">for</span> h &lt; n/<span class="hljs-number">3</span> &#123;        h = <span class="hljs-number">3</span>*h + <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> h &gt;= <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//进行子数组排序  h为1时为插入排序</span>        <span class="hljs-keyword">for</span> i := h; i &lt; n; i++ &#123;            k := i <span class="hljs-comment">//拿到第i张牌的时候</span>            <span class="hljs-keyword">for</span> &#123;                <span class="hljs-comment">//少于k张牌|当前牌重置到第一张|当前牌到了合适位置 从右向左移动</span>                <span class="hljs-keyword">if</span> k &lt; h || less(comparable[k-h], comparable[k]) &#123;                    <span class="hljs-keyword">break</span>                &#125;                exchange(comparable, k, k-h)                k -= h <span class="hljs-comment">//当然 每次交换位置后 k减h</span>            &#125;        &#125;        h = h / <span class="hljs-number">3</span>    &#125;&#125;</code></pre><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p>思路：分而治之</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> aux []<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-comment">//直接多申请一份数组空间 避免归并过程中反复申请回收</span>    aux = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(comparable),<span class="hljs-built_in">cap</span>(comparable))    <span class="hljs-comment">//topDownMerge(comparable, 0, len(comparable) - 1)</span>    bottomUpMerge(comparable, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(comparable) - <span class="hljs-number">1</span>)&#125;<span class="hljs-comment">//自顶向下归并</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topDownMerge</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, lo , hi <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> hi &lt;= lo &#123;        <span class="hljs-keyword">return</span>    &#125;    mid := lo + (hi-lo)/<span class="hljs-number">2</span>    topDownMerge(comparable,lo,mid)    topDownMerge(comparable,mid+<span class="hljs-number">1</span>,hi)    merge(comparable, lo, mid, hi)&#125;<span class="hljs-comment">//自顶向下归并</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bottomUpMerge</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> sz := <span class="hljs-number">1</span>; sz &lt; n; sz += sz &#123; <span class="hljs-comment">//sz子数组的大小</span>        <span class="hljs-keyword">for</span> lo := <span class="hljs-number">0</span>; lo &lt; n-sz; lo += sz + sz &#123; <span class="hljs-comment">//看做sz为1的子数组 向上合并的过程</span>            merge(comparable, lo, lo+sz<span class="hljs-number">-1</span>, <span class="hljs-keyword">int</span>(math.Min(<span class="hljs-keyword">float64</span>(lo+sz+sz<span class="hljs-number">-1</span>), <span class="hljs-keyword">float64</span>(n<span class="hljs-number">-1</span>))))        &#125;    &#125;&#125;<span class="hljs-comment">//原地归并(归并的重点 合并两个有序数组 并排好序)</span><span class="hljs-comment">//将a[lo,mid] 和 a[mid+1,hi]归并</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>, lo , mid , hi <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-comment">//两个数组的首位比较</span>    i , j := lo , mid+<span class="hljs-number">1</span>    <span class="hljs-comment">//临时数组 直接赋值会引用同一个空间 导致异常</span>    <span class="hljs-keyword">for</span> k := lo; k &lt;= hi; k++ &#123;        aux[k] = a[k]    &#125;    <span class="hljs-keyword">for</span> k := lo; k &lt;= hi; k++ &#123;        <span class="hljs-keyword">if</span> i &gt; mid &#123;    <span class="hljs-comment">//边界处理 左侧首元素大于尾元素位数时 表示左侧数组已经用尽</span>            a[k] = aux[j]            j++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j &gt; hi &#123;<span class="hljs-comment">//边界处理 右侧首元素大于尾元素位数时 表示右侧数组已经用尽</span>            a[k] = aux[i]            i++        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> less(aux[j], aux[i]) &#123;<span class="hljs-comment">//右侧表左侧小 取右侧呀 mark 必须是原数据(复制出来的aux)啊 写错了排查了半天</span>            a[k] = aux[j]            j++        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//正常取左侧</span>            a[k] = aux[i]            i++        &#125;    &#125;&#125;</code></pre><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><p>思路：将一个数组分为两个子数组 ，将两部分独立的排序。<br>将随机挑选的元素放在合适的位置（老数组排序好的位置），然后在递归调用排序前后两个子数组</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>1).小数组改为插入排序<br>2).三取样切分(使用子数组的一小部分元素的中位数切分数组 切分的好 效率肯定高 也要考虑代价 计算中位数)<br>3).熵最优排序 (对于重复元素的优化  将数组分为大于 小于 等于切分元素的三部分数组)</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Quick</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    quickSort(comparable, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(comparable)<span class="hljs-number">-1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, lo, hi <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> hi &lt;= lo &#123;        <span class="hljs-keyword">return</span>    &#125;    j := partition(comparable, lo, hi)    quickSort(comparable, lo, j<span class="hljs-number">-1</span>)    quickSort(comparable, j+<span class="hljs-number">1</span>, hi)&#125;<span class="hljs-comment">//快排的分区</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, lo, hi <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-comment">//将数组分为 a[lo,i-1]  a[i] a[i+1,hi]</span>    v := comparable[lo] <span class="hljs-comment">//这里也可以随机挑选一个</span>    i := lo         <span class="hljs-comment">//从第二个元素开始对比</span>    j := hi    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">//第二个开始</span>        i++        <span class="hljs-keyword">for</span> less(comparable[i], v) &#123;            i++            <span class="hljs-keyword">if</span> i == hi &#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">for</span> less(v, comparable[j]) &#123;            j--            <span class="hljs-keyword">if</span> j &lt;= lo &#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> i &gt;= j &#123;            <span class="hljs-keyword">break</span>        &#125;        exchange(comparable, i, j)    &#125;    <span class="hljs-comment">//把v=a[j]放到正确的位置</span>    exchange(comparable, lo, j)    <span class="hljs-keyword">return</span> j&#125;</code></pre><h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h2><p>思路：基于优先队列的排序方法 将所有元素插入一个查找最小元素的优先队列<br>然后再重复调用删除最小元素的操作 将他们顺序删除<br>二叉堆的表现方式：只用数组 不用指针 也就是树的顺序表达法<br>从a[0]开始的话 子节点在父节点（n位）的2n+1和2n+2位置上</p><pre><code class="hljs angelscript">func Heap(comparable []<span class="hljs-built_in">int</span>) &#123;    n := len(comparable)    <span class="hljs-comment">//构建堆</span>    <span class="hljs-keyword">for</span> k := (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; k &gt;= <span class="hljs-number">0</span>; k-- &#123;        sink(comparable, k, n)    &#125;    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;        exchange(comparable, <span class="hljs-number">0</span>, i)        sink(comparable, <span class="hljs-number">0</span>, i)    &#125;&#125;<span class="hljs-comment">//堆的下沉方法</span>func sink(comparable []<span class="hljs-built_in">int</span>, k, n <span class="hljs-built_in">int</span>) &#123;    j := <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> j &lt; n &#123;        <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span> &lt; n &amp;&amp; less(comparable[j+<span class="hljs-number">1</span>], comparable[j]) &#123;            j++        &#125;        <span class="hljs-keyword">if</span> !less(comparable[j], comparable[k]) &#123;            <span class="hljs-keyword">break</span>        &#125;        exchange(comparable, k, j)        k = j        j = <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>    &#125;&#125;</code></pre><h2 id="8-其他方法"><a href="#8-其他方法" class="headerlink" title="8.其他方法"></a>8.其他方法</h2><pre><code class="hljs go"><span class="hljs-comment">//比较数值大小</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">less</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    v := <span class="hljs-literal">true</span>    <span class="hljs-keyword">if</span> a &gt;= b &#123;        v = <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> v&#125;<span class="hljs-comment">//换位</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exchange</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, i , j <span class="hljs-keyword">int</span>)</span></span> &#123;    comparable[i], comparable[j] = comparable[j], comparable[i]&#125;<span class="hljs-comment">//是否排完序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSorted</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(comparable); i++ &#123;        <span class="hljs-keyword">if</span> less(comparable[i], comparable[i<span class="hljs-number">-1</span>]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><p>参考: 算法(第四版)<br>      算法导论<br>      go源码sort包  </p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
