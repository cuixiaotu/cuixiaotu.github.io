<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA成神之路二</title>
    <link href="/2021/03/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%BA%8C/"/>
    <url>/2021/03/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA成神之路二"><a href="#JAVA成神之路二" class="headerlink" title="JAVA成神之路二"></a>JAVA成神之路二</h1><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><h3 id="什么是面对对象"><a href="#什么是面对对象" class="headerlink" title="什么是面对对象"></a>什么是面对对象</h3><p>类是构造对象的模板或蓝图</p><p>封装是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方法、</p><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/characteristics?id=封装encapsulation" target="_blank" rel="noopener">封装(Encapsulation)</a></h3><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/characteristics?id=继承inheritance" target="_blank" rel="noopener">继承(Inheritance)</a></h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/characteristics?id=多态polymorphism" target="_blank" rel="noopener">多态(Polymorphism)</a></h3><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>端对端加密</title>
    <link href="/2021/02/20/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E5%8A%A0%E5%AF%86/"/>
    <url>/2021/02/20/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="端对端加密"><a href="#端对端加密" class="headerlink" title="端对端加密"></a>端对端加密</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><blockquote><p>End-to-end encryption (E2EE) is a system of communication where only the communicating users can read the messages. In principle, it prevents potential eavesdroppers – including telecom providers, Internet providers, and even the provider of the communication<br>service – from being able to access the cryptographic keys needed to decrypt the conversation.</p><p>端到端加密（E2EE）是一种通信系统，其中只有进行通信的用户才能阅读消息。原则上，它可以防止潜在的窃听者（包括电信提供商，Internet提供商，甚至通信提供商服务）能够访问解密对话所需的加密密钥。</p><p>The term “end-to-end encryption” originally only meant that the communication is never decrypted during its transport from the sender to the receiver.For example, around 2003, E2EE has been proposed as an additional layer of encryption for <a href="https://en.wikipedia.org/wiki/GSM" target="_blank" rel="noopener">GSM</a> or <a href="https://en.wikipedia.org/wiki/Terrestrial_Trunked_Radio" target="_blank" rel="noopener">TETRA</a>,in addition to the existing radio encryption protecting the communication between the mobile device and the network infrastructure. This has been standardised by SFPG for TETRA.Note that in TETRA E2EE, the keys are generated by a Key Management Centre (KMC) or a Key Management Facility (KMF), not by the communicating users.</p><p>Later, around 2014, the meaning of “end-to-end encryption” started to evolve requiring that not only the communication stays encrypted during transport, but also that the provider of the communication service is not able to decrypt the communications either by having access to the private key, or by having the capability to undetectably inject an adversarial public key as part of a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">man-in-the-middle attack</a>. This new meaning is now the widely accepted one.</p><p>“端到端加密”最初仅表示通信从发送方到接收方的传输过程中永远不会解密。 例如，2003年左右，E2EE已经被提出作为加密额外层<a href="https://en.wikipedia.org/wiki/GSM" target="_blank" rel="noopener">GSM </a>或<a href="https://en.wikipedia.org/wiki/Terrestrial_Trunked_Radio" target="_blank" rel="noopener">TETRA</a>，在除了现有的无线电加密保护移动设备和网络基础设施之间的通信。SFPG已将其标准化为TETRA。请注意，在TETRA E2EE中，密钥是由密钥管理中心（KMC）或密钥管理工具（KMF）生成的，而不是由通信用户生成的。</p><p>后来，大约在2014年，“端到端加密”的含义开始发展，不仅要求通信在传输过程中保持加密，而且通信服务的提供者必须不能够解密通信无论是其访问私有密钥，或有注射对抗性公共密钥的能力，无法检测作为一部分中间人攻击。现在，这一新含义已被广泛接受。</p><p>[*<a href="https://en.wikipedia.org/wiki/End-to-end_encryption" target="_blank" rel="noopener">摘自维基百科</a>*]</p></blockquote><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h2><p>人生而自由，隐私和安全性存在于我们的DNA中，这就是我们在应用程序中内置端到端加密的原因。端到端加密后，您的消息，照片，视频，语音消息，文档，状态更新和呼叫就可以避免落入错误的人手中。</p><h2 id="3-方案"><a href="#3-方案" class="headerlink" title="3.方案"></a>3.方案</h2><h3 id="3-1-RocketChat"><a href="#3-1-RocketChat" class="headerlink" title="3.1 RocketChat"></a>3.1 RocketChat</h3><p>rocketChat的端对端加密还在测试阶段，并不影响我们对其的学习。整理的流程图如下：</p><p>1.客户端生成随机密码，用于sha256后生成主密钥</p><p>2.客户端生成密钥对，私钥通过主密钥加密后，保存公钥和加密后的私钥到用户表</p><p>3.客户端开启端对端加密会话,根据当前会话生成会话密钥，会话密钥经私钥加密后存储在订阅表中</p><p>4.来往消息加解密都是通过经过本地解密后的会话密钥</p><p><img src="rocket-chat-e2ee.png" srcset="/img/loading.gif" alt=""></p><p>优点：</p><p>1.官方源码支持</p><p>2.支持群聊</p><p>3.兼容性强，之前的未加密会话可以无缝切换成加密会话</p><p>缺点：</p><p>1.官方方案还在Beta期</p><p>2.搜索操作将找不到加密房间的加密消息</p><h3 id="3-2-telegram"><a href="#3-2-telegram" class="headerlink" title="3.2 telegram"></a>3.2 telegram</h3><p>telegram的加密基于Diffie Hellman算法，确保共享key穿越不安全的方法。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>类比:Alice和Bob公开使用黄色的画布，两人选择各自的秘密颜色保留，Alice选择红色，Bob选择蓝绿色。两人将黄色和各自秘密颜色混色，变为棕黄色和浅蓝色，然后公开两种混色。最后双方拿到对方的混合色和自己的秘密颜色混合，最终形成一致的配色。</p><p>实际使用的很大的数字和整数模p的乘法组让超级计算机也没办法短时间内计算出密钥。其他实现算法椭圆曲线和</p><p><img src="color.jpg" srcset="/img/loading.gif" alt="img"></p><p>生成会话密钥</p><p>1.Alice开启和Bob的加密会话，生素数p和高阶元素g</p><p>2.客户端检查p是否为2048位的素数，且g为循环子组素数阶数(p-1)/2.由于g始终等于2,3,4,5,6,7,很容易完成二次互易定理。</p><p>3.Alice 生成随机的a和计算<code>g_a := pow(g, a) mod dh_prime</code></p><p>4.Bob接收Alice的基本信息和DH生成的最新参数配置，自身生成一个随机数b</p><p>5.Bob生成最终共享密钥 <code>key = (pow(g_a, b) mod dh_prime)</code></p><p>6.Bob返回给Alice<code>g_b := pow(g, b) mod dh_prime</code></p><p>7.Alice接收g_b，并可以得出<code>key = (pow(g_b, a) mod dh_prime)</code></p><p><img src="telegram.png" srcset="/img/loading.gif" alt=""></p><p>优点：</p><p>1.采用Diffie-Hellman加密方式</p><p>2.完善的前向保密</p><p>3.加密维度 消息级</p><p>缺点：</p><p>1.计算密集</p><p>2.不支持群聊</p><h3 id="3-3-WhatsApp"><a href="#3-3-WhatsApp" class="headerlink" title="3.3 WhatsApp"></a>3.3 WhatsApp</h3><p>基于Signal Protocol 协议</p><p><img src="lun.png" srcset="/img/loading.gif" alt="img"></p><p>棘轮为单向转动的特殊齿轮，即算法不断的生成新的Message Key用于加密消息，且即使破解某一个Message Key只能破解单条消息，也无法破解之前消息。</p><p>1.用户注册时候生成Identity Key Pair,Signed Pre Key 和One-Time Pre Keys，传输给服务端并储存到用户表。</p><ul><li>Identity Key Pair：身份密钥对，安装时生成的长期Curve25519密钥对</li><li>Signed Pre Key：签名预密钥，安装时生成的中期Curve255129密钥对</li><li>One-Time Pre Keys：一次性预密钥，用于加密消息的80位值，32位用于AES-256密钥，32位用于HMAC-SHA256,16位用于IV</li></ul><p>2.创建一个加密会话，（除非重装APP或更换设备），则无需重建会话。</p><p> （为了区分发信人和收信人，认识两位老同学Alice和Bob）</p><ul><li><p>Alice请求Bob的Identity Key，Signed Pre Key，和一个One-Time Pre Key。</p></li><li><p>服务端返回公共keys。One-Time Pre Key一旦返回则在服务端删除，若没有了且未补充生成，则不返回One-Time Pre Key。</p></li><li><p>Alice接收Bob的Identity Key为<code>I recipient</code>，Signed Pre Key为<code>S recipient</code>，One-Time Pre Key为<code>O recipient</code>。</p></li><li><p>Alice生成短暂的密钥对Curve25519,<code>E initiator。</code></p></li><li><p>Alice把自己的Identity Key当<code>I initiator</code>。</p></li><li><p>Alice计算主密钥：(如果没有One-Time Pre Keys了最后的ECDH被忽略)</p><pre><code class="hljs reasonml">master_secret = <span class="hljs-constructor">ECDH(I <span class="hljs-params">initiator</span>,S <span class="hljs-params">recipient</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">ECDH(E <span class="hljs-params">initiator</span>,I <span class="hljs-params">recipient</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">ECDH(E <span class="hljs-params">initiator</span>,S <span class="hljs-params">recipient</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">ECDH(E <span class="hljs-params">initiator</span>,O <span class="hljs-params">recipient</span>)</span></code></pre></li><li><p>Alice用主密钥创建Root Key和Chain Key。</p></li></ul><p>3.会话创建后，客户端使用AES256_CBC加密和HMAC-SHA256验证消息。Message Key随着每个消息短暂存在且变化，并且在发送或接收消息后无法重建，解密Message Key由Alice的Chain Key发送的每一条消息生成。</p><p>4.Bob收到消息后，使用Alice公钥和自己的密钥，计算出master_secret，从而得到当前消息的Message Key。</p><p>5.Bob和Alice使用Message Key进行加密通信。</p><p>优点：</p><p>1.安全系数高</p><p>2.支持加密各种附件，语音视频，群组</p><p>3.完善的前向保密</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p>1.<a href="https://scontent.whatsapp.net/v/t39.8562-34/122249142_469857720642275_2152527586907531259_n.pdf/WA_Security_WhitePaper.pdf?ccb=3&_nc_sid=2fbf2a&_nc_ohc=AKi8-7dPSA4AX9DqpdV&_nc_ht=scontent.whatsapp.net&oh=dfa7bc578cf584b3c21644e79dce60d0&oe=60663219" target="_blank" rel="noopener">WhatsApp白皮书 </a></p><p>2.<a href="https://docs.rocket.chat/guides/security/end-to-end-encryption-algorithms" target="_blank" rel="noopener">rocketchat官方文档</a></p><p>3.<a href="https://core.telegram.org/api/end-to-end" target="_blank" rel="noopener">telegram官方文档</a>     </p>]]></content>
    
    
    <categories>
      
      <category>IM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA成神之路一</title>
    <link href="/2020/09/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B8%80/"/>
    <url>/2020/09/02/JAVA%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA成神之路一"><a href="#JAVA成神之路一" class="headerlink" title="JAVA成神之路一"></a>JAVA成神之路一</h1><h2 id="1-安装部署"><a href="#1-安装部署" class="headerlink" title="1.安装部署"></a>1.安装部署</h2><p>​    </p><ol><li><p>linux部署 还是得用openJava 其中阿里的开源dragonwell不错</p><pre><code class="hljs vim">wget http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/alibaba/dragonwell8/releases/download/dragonwell-<span class="hljs-number">8.5</span>.<span class="hljs-number">5</span>_jdk8u275-ga/Alibaba_Dragonwell_8.<span class="hljs-number">5.5</span>-GA_Linux_x64.tar.gztar xf Alibaba_Dragonwell_8.<span class="hljs-number">5.5</span>-GA_Linux_x64.tar.gz -C /<span class="hljs-keyword">opt</span>JAVA_HOME=/<span class="hljs-keyword">opt</span>/jdk8u275-b1/PATH=SPATH:$JAVA_HOME/binjava -<span class="hljs-keyword">version</span>// 持久化<span class="hljs-keyword">cat</span> &gt;&gt; ~/.bashrc</code></pre></li><li><p>window环境 只是开发的话 建议去官网直接下载<br><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p></li></ol><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h3><p>整型</p><table><thead><tr><th>数据类型</th><th>存储</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1字节</td><td>-128(-2^7)到127(2^7-1)</td><td>0</td></tr><tr><td>short</td><td>2字节</td><td>-32,768 (-2^15)到32,767 (2^15-1)</td><td>0</td></tr><tr><td>int</td><td>4字节</td><td>-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)</td><td>0</td></tr><tr><td>long</td><td>8字节</td><td>-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)</td><td>0l</td></tr></tbody></table><p>浮点 float double</p><table><thead><tr><th>数据类型</th><th>存储</th><th>范围</th><th>默认值</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>1.4E-45 （2^-149）到（2^128-1）</td><td>2.15F</td></tr><tr><td>double8</td><td>8字节</td><td>4.9E-324 （2^-1074）到1.7976931348623157E308 （2^1024-1）</td><td>3.12D</td></tr></tbody></table><p>布尔 boolean</p><p>​    false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换</p><p>字符 char</p><p>​    char类型描述了UTF-16编码中的一个代码单元,可以和int类型互换，对应维护的字符表。</p><h3 id="2-2-自动拆装箱"><a href="#2-2-自动拆装箱" class="headerlink" title="2.2 自动拆装箱"></a>2.2 自动拆装箱</h3><p>Java 语言是一个面向对象的语言，但是 Java 中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便（集合类中），为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p><p>自动装箱: 就是将基本数据类型自动转换成对应的包装类。<br>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p><p>包装类均位于 <code>java.lang</code> 包，包装类和基本数据类型的对应关系如下表所示</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="2-3-字符串-String"><a href="#2-3-字符串-String" class="headerlink" title="2.3  字符串 String"></a>2.3  字符串 String</h3><p>字符串就是Unicode字符序列，一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。如果你需要一个可修改的字符串，应该使用StringBuffer 或者 StringBuilder。否则会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的string对象被创建出来。</p><h4 id="2-3-1-字符串的截取"><a href="#2-3-1-字符串的截取" class="headerlink" title="2.3.1 字符串的截取"></a>2.3.1 字符串的截取</h4><p>substring 截取字符串并返回其[beginIndex,endIndex-1]范围内的内容，会创建一个全新的string对象。</p><h4 id="2-3-2-字符串的拼接"><a href="#2-3-2-字符串的拼接" class="headerlink" title="2.3.2 字符串的拼接"></a>2.3.2 字符串的拼接</h4><p>concat              创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个                          新的String对象并返回</p><p>+                          Java提供的一个语法糖,其实现原理是使用<code>StringBuilder.append</code></p><p>StringBuilder     字符数组不是用final形容，可以修改，在拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p><p>StringBuffer       在StringBuilder的基础上，用synchronized描述append,线程安全的</p><p>StringUtils.concat  也是通过<code>StringBuilder</code>来实现的</p><pre><code class="hljs autohotkey">性能耗时`StringBuilder`&lt;`StringBuffer`&lt;`concat`&lt;`+`&lt;`StringUtils.join</code></pre><h4 id="2-3-3-字符串的替换"><a href="#2-3-3-字符串的替换" class="headerlink" title="2.3.3 字符串的替换"></a>2.3.3 字符串的替换</h4><p>replace(CharSequence target, CharSequence replacement) ，用replacement替换所有的target，两个参数都是字符串。</p><p>replaceAll(String regex, String replacement) ，用replacement替换所有的regex匹配项，regex很明显是个正则表达式，replacement是字符串。</p><p>replaceFirst(String regex, String replacement) ，基本和replaceAll相同，区别是只替换第一个匹配项。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 数据结构</title>
    <link href="/2020/08/20/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/08/20/Redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h1><p>最近又重新看了一遍Redis 整理一下阅读笔记</p><h2 id="1-redis支持的数据结构"><a href="#1-redis支持的数据结构" class="headerlink" title="1.redis支持的数据结构"></a>1.redis支持的数据结构</h2><p>字符串，哈希，列表，集合，有序集合<br>string，hash,list,set,sorted set</p><h2 id="2-redis内部的数据结构"><a href="#2-redis内部的数据结构" class="headerlink" title="2.redis内部的数据结构"></a>2.redis内部的数据结构</h2><p>简单动态字符串<br>双向链表<br>压缩链表<br>哈希表<br>跳表<br>整数数组</p><h2 id="3-数据结构关系如下"><a href="#3-数据结构关系如下" class="headerlink" title="3.数据结构关系如下"></a>3.数据结构关系如下</h2><p><img src="redis01_0.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="4-内部数据结构介绍"><a href="#4-内部数据结构介绍" class="headerlink" title="4.内部数据结构介绍"></a>4.内部数据结构介绍</h2><h3 id="4-1-简单动态字符串"><a href="#4-1-简单动态字符串" class="headerlink" title="4.1 简单动态字符串"></a>4.1 简单动态字符串</h3><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span>    <span class="hljs-comment">//记录buf数组中已使用字节的数量</span>    <span class="hljs-comment">//等于SDS所保存字符串的长度</span>    <span class="hljs-keyword">int</span> len;    <span class="hljs-comment">//记录buf数组中未使用字节的数量</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">free</span>;    <span class="hljs-comment">//字节数组，用于保存字符串</span>    <span class="hljs-keyword">char</span> buf[];&#125;;</code></pre><p>len: 以O(1)时间复杂度获取长度<br>free:  避免缓冲区溢出  减少字符串修改时的空间重分配次数 (C的空间操作真的要小心翼翼)<br>二进制安全 以编码和<br>同样以\0空字符结尾(不记录与长度中，真实长度会比len大1)<br>兼容部分C字符串的长度</p><h3 id="4-2-双向链表"><a href="#4-2-双向链表" class="headerlink" title="4.2 双向链表"></a>4.2 双向链表</h3><pre><code class="hljs cpp">#链表节点<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span>    <span class="hljs-comment">// 前置节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">prev</span>;</span>    <span class="hljs-comment">// 后置节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> * <span class="hljs-title">next</span>;</span>    <span class="hljs-comment">//节点的值</span>    <span class="hljs-keyword">void</span> * value;&#125;listNode;#链表<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span>    <span class="hljs-comment">//</span>    表头节点    listNode * head;    <span class="hljs-comment">//</span>    表尾节点    listNode * tail;    <span class="hljs-comment">//</span>    链表所包含的节点数量    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len;    <span class="hljs-comment">//</span>    节点值复制函数    <span class="hljs-keyword">void</span> *(*dup)(<span class="hljs-keyword">void</span> *ptr);    <span class="hljs-comment">//</span>    节点值释放函数    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-keyword">void</span> *ptr);    <span class="hljs-comment">//</span>    节点值对比函数    <span class="hljs-keyword">int</span> (*match)(<span class="hljs-keyword">void</span> *ptr,<span class="hljs-keyword">void</span> *key);&#125; <span class="hljs-built_in">list</span>;</code></pre><p>双端： 获取prev和next时间复杂度都为O(1)<br>无环： 头Node的prev和尾Node的next都指向Null<br>dup，free，match 实现多态链表的特定函数</p><h3 id="4-3-哈希表（字典）"><a href="#4-3-哈希表（字典）" class="headerlink" title="4.3 哈希表（字典）"></a>4.3 哈希表（字典）</h3><pre><code class="hljs arduino"><span class="hljs-comment">//哈希表</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span>    <span class="hljs-comment">//哈希表数组</span>    dictEntry **table;    <span class="hljs-comment">//哈希表大小</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-built_in">size</span>;    <span class="hljs-comment">//哈希表大小掩码，用于计算索引值</span>    <span class="hljs-comment">//总是等于size-1</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;    <span class="hljs-comment">//该哈希表已有节点的数量</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;&#125; dictht;<span class="hljs-comment">//哈希表节点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span>    <span class="hljs-comment">//键</span>    <span class="hljs-keyword">void</span> *key;    <span class="hljs-comment">//值</span>    <span class="hljs-keyword">union</span>&#123;        <span class="hljs-keyword">void</span> *val;        uint64_tu64;        int64_ts64;    &#125; v;    <span class="hljs-comment">//指向下个哈希表节点，形成链表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span>&#125; dictEntry;<span class="hljs-comment">//字典</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span>    <span class="hljs-comment">//类型特定函数</span>    dictType *type;    <span class="hljs-comment">//私有数据</span>    <span class="hljs-keyword">void</span> *privdata;    <span class="hljs-comment">//哈希表</span>    dictht ht[<span class="hljs-number">2</span>];    <span class="hljs-comment">// rehash索引</span>    <span class="hljs-comment">//当rehash不在进行时，值为-1</span>    in trehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span>&#125; dict;<span class="hljs-comment">//字典类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span>    <span class="hljs-comment">//计算哈希值的函数</span>    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-params">(*hashFunction)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key)</span></span>;    <span class="hljs-comment">//复制键的函数</span>    <span class="hljs-keyword">void</span> *(*keyDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);    <span class="hljs-comment">//复制值的函数</span>    <span class="hljs-keyword">void</span> *(*valDup)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *obj);    <span class="hljs-comment">//对比键的函数</span>    <span class="hljs-keyword">int</span> (*keyCompare)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key2);    <span class="hljs-comment">//销毁键的函数</span>    <span class="hljs-keyword">void</span> (*keyDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *key);    <span class="hljs-comment">//销毁值的函数</span>    <span class="hljs-keyword">void</span> (*valDestructor)(<span class="hljs-keyword">void</span> *privdata, <span class="hljs-keyword">void</span> *obj);&#125; dictType;</code></pre><p>哈希算法 ： 把一对键值对存到字典中，先回对键进行计算出哈希值和索引值，然后根据索引值把哈希表节点放到哈希表数组指定的位置上。<br>哈希冲突 ： 众所周知，拉链法和直线寻址法。直线寻址会过多分配空间且不好维护，拉链法在命中同一哈希key太多时，性能下降。redis的解决方案，拉链法和rehash。<br>rehash ：<br>触发条件<br>load_factor = ht[0].used / ht[0].size ;<br>当服务器未进行BGSAVE和BGREWRITEAOF 且load_factor大于等于1<br>当服务器在执行BGSAVE和BGREWRITEAOF 且load_factor大于等于5<br>缩容 load_factor则小于等于0.1<br>行为</p><p>1) 给字典中的ht[1]分配空间，扩容为ht[0].used*2n 缩容为ht[0].used/2n<br>2) 将保存在ht[0]中的所有键值对重新计算哈希值和索引值，然后把键值对放置到ht[1]哈希表制定位置上<br>3) 迁移完成后，释放ht[0],将ht[1]设置为ht[0]，为ht[1]新创建个空白哈希表<br>思考问题：<br>1.哈希表过大时迁移是否太耗资源，堵塞其他操作<br> 渐进式rehash 通过rehashidx索引计数器逐步迁移<br>2.rehash过程中的增删改查，是如何操作的<br>  增 只操作ht[1]<br>  删 改 查  会操作两个哈希表</p><h3 id="4-4-跳表"><a href="#4-4-跳表" class="headerlink" title="4.4 跳表"></a>4.4 跳表</h3><pre><code class="hljs cpp"><span class="hljs-comment">//跳表节点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span>    <span class="hljs-comment">//层</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span>        <span class="hljs-comment">//前进指针</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span>        <span class="hljs-comment">//跨度</span>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> span;    &#125; level[];    <span class="hljs-comment">//后退指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span>    <span class="hljs-comment">//分值</span>    <span class="hljs-keyword">double</span> score;    <span class="hljs-comment">//成员对象</span>    robj *obj;&#125; zskiplistNode;<span class="hljs-comment">//跳表</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span>    <span class="hljs-comment">//表头节点和表尾节点</span>    structz skiplistNode *header, *tail;    <span class="hljs-comment">//表中节点的数量</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;    <span class="hljs-comment">//表中层数最大的节点的层数</span>    <span class="hljs-keyword">int</span> level;&#125; zskiplist;</code></pre><p>用于有序集合或集群节点中</p><h3 id="4-5-整数集合"><a href="#4-5-整数集合" class="headerlink" title="4.5 整数集合"></a>4.5 整数集合</h3><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> struct <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span> &#123;    <span class="hljs-comment">//编码方式</span>    <span class="hljs-built_in">uint</span>32_t encoding;    <span class="hljs-comment">//集合包含的元素数量</span>    <span class="hljs-built_in">uint</span>32_t length;    <span class="hljs-comment">//保存元素的数组</span>    <span class="hljs-built_in">int</span>8_t contents[];&#125; <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span>;</code></pre><p>升级</p><p>1) 根据新元素的类型 扩展整数集合底层数组空间大小 并为新元素分配空间<br>2) 将底层数组所有的元素转换为新元素类型 将类型转换后的元素放到正确的位置上去<br>3) 将新元素添加按到底层数组里</p><p>降级<br>不支持降级，故升级后的编码 即使大元素被删 也不会恢复为之前的编码</p><h3 id="4-6-压缩列表"><a href="#4-6-压缩列表" class="headerlink" title="4.6 压缩列表"></a>4.6 压缩列表</h3><p><img src="redis01_1.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="redis01_2.jpg" srcset="/img/loading.gif" alt=""></p><p>压缩列表是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结枃。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值  </p><p>参考: </p><ul><li>Redis官方文档 </li><li>Redis设计与实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2020/07/17/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2020/07/17/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>有序数组查找<br>有序数组的查找使用二分查找可以减少比较次数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rank</span><span class="hljs-params">(Key key)</span></span>&#123;    <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>,hi = N -<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (lo &lt;= hi)&#123;        <span class="hljs-keyword">int</span> mid = (hi-lo)/<span class="hljs-number">2</span> + lo;        <span class="hljs-keyword">int</span> cmp = key.compareTo(keys[mid]);        <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) hi =mid-<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) lo = mid +<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;    &#125;    <span class="hljs-keyword">return</span> lo;&#125;</code></pre><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>在树的任意一个节点，其左子树的每个节点的值都要小于这个节点的值，而右子树节点的值都要大于这个节点的值。（基于二分查找，满二叉查找数）</p><p><img src="binary_search_tree.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;  <span class="hljs-keyword">private</span> Node tree;  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;    Node p = tree;    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-keyword">private</span> Node left;    <span class="hljs-keyword">private</span> Node right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;    tree = <span class="hljs-keyword">new</span> Node(data);    <span class="hljs-keyword">return</span>;  &#125;  Node p = tree;  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;        p.right = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.right;    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;        p.left = <span class="hljs-keyword">new</span> Node(data);        <span class="hljs-keyword">return</span>;      &#125;      p = p.left;    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;  Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span>  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;    pp = p;    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;    <span class="hljs-keyword">else</span> p = p.left;  &#125;  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span>  <span class="hljs-comment">// 要删除的节点有两个子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span>    Node minP = p.right;    Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span>    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;      minPP = minP;      minP = minP.left;    &#125;    p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span>    p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span>    pp = minPP;  &#125;  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span>  Node child; <span class="hljs-comment">// p的子节点</span>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;  <span class="hljs-keyword">else</span> pp.right = child;&#125;</code></pre><table><thead><tr><th>算法</th><th align="center">查找</th><th align="right">插入</th></tr></thead><tbody><tr><td>顺序查询</td><td align="center">N/2</td><td align="right">N</td></tr><tr><td>二分查找</td><td align="center">lgN</td><td align="right">N/2</td></tr><tr><td>二叉树查找</td><td align="center">lgN</td><td align="right">lgN</td></tr></tbody></table><p>二叉查找树平均情况下 性能还是不错的，但是在增删的情况下，无法保持平衡，最终可能退化为链表导致性能大幅度下降。</p><h2 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h2><p>2-3查找树 ： 一棵空树或由2-结点和3-结点组成的树<br>2-结点：含一个键和两个链接，左链接指向的2-3树中的结点都小于该结点，右链接指向的2-3树中的结点都大于该结点s<br>3-结点：含两个键和三个链接，左链接指向的2-3树中的结点都小于该结点，右链接指向的2-3树中的结点都大于该结点，中结点指向的结点的键位于该结点两个键的中间</p><p><img src="2-3_tree.png" srcset="/img/loading.gif" alt=""></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>从根节点开始，若和节点中的</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>1） 如果是空树，创建一个节点并存入值<br>2） 否则找到叶子节点<br>3） 如果叶子节点只有一个值，新值也存入该节点<br>4） 如果叶子节点超过两个值，分离该节点，并把三个值的中位值提升至父节点<br>5） 如果父节点有三个值，继续4的操作 直至根节点</p><pre><code class="hljs java"></code></pre><h2 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h2><p>1) 根节点是黑色的<br>2) 每个节点非黑既红<br>2) 每个叶子节点都是黑色的空节点（nil）<br>3) 任何相邻的节点都不能同时为红色<br>4) 每个节点 到达其可达的叶子节点的所有路径都包含相同数目的黑色节点</p><p><img src="red_black_tree.png" srcset="/img/loading.gif" alt=""></p><p>（可以结合上面的2-3图一起看哟 画图不易）</p><p>旋转还是挺复杂的 有空再来慢慢画图和编码 留一个坑在这里 </p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Just Sort</title>
    <link href="/2020/07/04/just-sort/"/>
    <url>/2020/07/04/just-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="排序大全"><a href="#排序大全" class="headerlink" title="排序大全"></a>排序大全</h1><p>排序是将一组对象按照某种逻辑顺序重新排列的过程。<br>每次都草草的看下排序似懂非懂，知其然不知其所以然,这次用go简单的实现一下。</p><hr><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>思路:两两比较 轻的上浮 重的下沉</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bubble</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123; <span class="hljs-comment">//n次是必须的</span>        <span class="hljs-comment">//优化思路 每次比较完 最重的已经沉到底了（多减1 是两两比较的原因）</span>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; j++ &#123;            <span class="hljs-keyword">if</span> less(comparable[j+<span class="hljs-number">1</span>], comparable[j]) &#123;                exchange(comparable, j, j+<span class="hljs-number">1</span>)            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>思路:每次选出最小值放在将它和数组的第一个元素交换位置，再在剩余的元素中反复操作</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Selection</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123; <span class="hljs-comment">//进行N次变换</span>        min := i <span class="hljs-comment">//每次重置最小值为开始值</span>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;            <span class="hljs-keyword">if</span> less(comparable[j], comparable[min]) &#123;                min = j            &#125;        &#125;        exchange(comparable, i, min)    &#125;&#125;</code></pre><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>思路：按照理牌的思路 每来一张牌 把牌放在已经排序好的合适位置</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Insertion</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;        k := i <span class="hljs-comment">//拿到第i张牌的时候</span>        <span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">//嘿嘿 这里用的算法导论里的while 大家用for一个原理</span>            <span class="hljs-comment">//只有一张牌|当前牌重置到第一张|当前牌到了合适位置 从右向左移动</span>            <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-number">0</span> || less(comparable[k<span class="hljs-number">-1</span>], comparable[k]) &#123;                <span class="hljs-keyword">break</span>            &#125;            exchange(comparable, k, k<span class="hljs-number">-1</span>)            k-- <span class="hljs-comment">//当然 每次交换位置后 k减1</span>        &#125;    &#125;&#125;</code></pre><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h2><p>思路:插入排序的优化 前面的排序只会交换相邻位置  希尔交换不相邻元素对数组局部进行排序<br>使数组中间隔为h的元素都是有序的 h按一定规律（未有最优递增序列）递减</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Shell</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    h := <span class="hljs-number">1</span>    <span class="hljs-comment">//设置步长 (递增序列)</span>    <span class="hljs-keyword">for</span> h &lt; n/<span class="hljs-number">3</span> &#123;        h = <span class="hljs-number">3</span>*h + <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> h &gt;= <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//进行子数组排序  h为1时为插入排序</span>        <span class="hljs-keyword">for</span> i := h; i &lt; n; i++ &#123;            k := i <span class="hljs-comment">//拿到第i张牌的时候</span>            <span class="hljs-keyword">for</span> &#123;                <span class="hljs-comment">//少于k张牌|当前牌重置到第一张|当前牌到了合适位置 从右向左移动</span>                <span class="hljs-keyword">if</span> k &lt; h || less(comparable[k-h], comparable[k]) &#123;                    <span class="hljs-keyword">break</span>                &#125;                exchange(comparable, k, k-h)                k -= h <span class="hljs-comment">//当然 每次交换位置后 k减h</span>            &#125;        &#125;        h = h / <span class="hljs-number">3</span>    &#125;&#125;</code></pre><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p>思路：分而治之</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> aux []<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-comment">//直接多申请一份数组空间 避免归并过程中反复申请回收</span>    aux = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(comparable),<span class="hljs-built_in">cap</span>(comparable))    <span class="hljs-comment">//topDownMerge(comparable, 0, len(comparable) - 1)</span>    bottomUpMerge(comparable, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(comparable) - <span class="hljs-number">1</span>)&#125;<span class="hljs-comment">//自顶向下归并</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topDownMerge</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, lo , hi <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> hi &lt;= lo &#123;        <span class="hljs-keyword">return</span>    &#125;    mid := lo + (hi-lo)/<span class="hljs-number">2</span>    topDownMerge(comparable,lo,mid)    topDownMerge(comparable,mid+<span class="hljs-number">1</span>,hi)    merge(comparable, lo, mid, hi)&#125;<span class="hljs-comment">//自顶向下归并</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bottomUpMerge</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    n := <span class="hljs-built_in">len</span>(comparable)    <span class="hljs-keyword">for</span> sz := <span class="hljs-number">1</span>; sz &lt; n; sz += sz &#123; <span class="hljs-comment">//sz子数组的大小</span>        <span class="hljs-keyword">for</span> lo := <span class="hljs-number">0</span>; lo &lt; n-sz; lo += sz + sz &#123; <span class="hljs-comment">//看做sz为1的子数组 向上合并的过程</span>            merge(comparable, lo, lo+sz<span class="hljs-number">-1</span>, <span class="hljs-keyword">int</span>(math.Min(<span class="hljs-keyword">float64</span>(lo+sz+sz<span class="hljs-number">-1</span>), <span class="hljs-keyword">float64</span>(n<span class="hljs-number">-1</span>))))        &#125;    &#125;&#125;<span class="hljs-comment">//原地归并(归并的重点 合并两个有序数组 并排好序)</span><span class="hljs-comment">//将a[lo,mid] 和 a[mid+1,hi]归并</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>, lo , mid , hi <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-comment">//两个数组的首位比较</span>    i , j := lo , mid+<span class="hljs-number">1</span>    <span class="hljs-comment">//临时数组 直接赋值会引用同一个空间 导致异常</span>    <span class="hljs-keyword">for</span> k := lo; k &lt;= hi; k++ &#123;        aux[k] = a[k]    &#125;    <span class="hljs-keyword">for</span> k := lo; k &lt;= hi; k++ &#123;        <span class="hljs-keyword">if</span> i &gt; mid &#123;    <span class="hljs-comment">//边界处理 左侧首元素大于尾元素位数时 表示左侧数组已经用尽</span>            a[k] = aux[j]            j++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j &gt; hi &#123;<span class="hljs-comment">//边界处理 右侧首元素大于尾元素位数时 表示右侧数组已经用尽</span>            a[k] = aux[i]            i++        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> less(aux[j], aux[i]) &#123;<span class="hljs-comment">//右侧表左侧小 取右侧呀 mark 必须是原数据(复制出来的aux)啊 写错了排查了半天</span>            a[k] = aux[j]            j++        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//正常取左侧</span>            a[k] = aux[i]            i++        &#125;    &#125;&#125;</code></pre><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h2><p>思路：将一个数组分为两个子数组 ，将两部分独立的排序。<br>将随机挑选的元素放在合适的位置（老数组排序好的位置），然后在递归调用排序前后两个子数组</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>1).小数组改为插入排序<br>2).三取样切分(使用子数组的一小部分元素的中位数切分数组 切分的好 效率肯定高 也要考虑代价 计算中位数)<br>3).熵最优排序 (对于重复元素的优化  将数组分为大于 小于 等于切分元素的三部分数组)</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Quick</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span></span> &#123;    quickSort(comparable, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(comparable)<span class="hljs-number">-1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, lo, hi <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> hi &lt;= lo &#123;        <span class="hljs-keyword">return</span>    &#125;    j := partition(comparable, lo, hi)    quickSort(comparable, lo, j<span class="hljs-number">-1</span>)    quickSort(comparable, j+<span class="hljs-number">1</span>, hi)&#125;<span class="hljs-comment">//快排的分区</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, lo, hi <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;    <span class="hljs-comment">//将数组分为 a[lo,i-1]  a[i] a[i+1,hi]</span>    v := comparable[lo] <span class="hljs-comment">//这里也可以随机挑选一个</span>    i := lo         <span class="hljs-comment">//从第二个元素开始对比</span>    j := hi    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">//第二个开始</span>        i++        <span class="hljs-keyword">for</span> less(comparable[i], v) &#123;            i++            <span class="hljs-keyword">if</span> i == hi &#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">for</span> less(v, comparable[j]) &#123;            j--            <span class="hljs-keyword">if</span> j &lt;= lo &#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> i &gt;= j &#123;            <span class="hljs-keyword">break</span>        &#125;        exchange(comparable, i, j)    &#125;    <span class="hljs-comment">//把v=a[j]放到正确的位置</span>    exchange(comparable, lo, j)    <span class="hljs-keyword">return</span> j&#125;</code></pre><h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h2><p>思路：基于优先队列的排序方法 将所有元素插入一个查找最小元素的优先队列<br>然后再重复调用删除最小元素的操作 将他们顺序删除<br>二叉堆的表现方式：只用数组 不用指针 也就是树的顺序表达法<br>从a[0]开始的话 子节点在父节点（n位）的2n+1和2n+2位置上</p><pre><code class="hljs angelscript">func Heap(comparable []<span class="hljs-built_in">int</span>) &#123;    n := len(comparable)    <span class="hljs-comment">//构建堆</span>    <span class="hljs-keyword">for</span> k := (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; k &gt;= <span class="hljs-number">0</span>; k-- &#123;        sink(comparable, k, n)    &#125;    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;        exchange(comparable, <span class="hljs-number">0</span>, i)        sink(comparable, <span class="hljs-number">0</span>, i)    &#125;&#125;<span class="hljs-comment">//堆的下沉方法</span>func sink(comparable []<span class="hljs-built_in">int</span>, k, n <span class="hljs-built_in">int</span>) &#123;    j := <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> j &lt; n &#123;        <span class="hljs-keyword">if</span> j+<span class="hljs-number">1</span> &lt; n &amp;&amp; less(comparable[j+<span class="hljs-number">1</span>], comparable[j]) &#123;            j++        &#125;        <span class="hljs-keyword">if</span> !less(comparable[j], comparable[k]) &#123;            <span class="hljs-keyword">break</span>        &#125;        exchange(comparable, k, j)        k = j        j = <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>    &#125;&#125;</code></pre><h2 id="8-其他方法"><a href="#8-其他方法" class="headerlink" title="8.其他方法"></a>8.其他方法</h2><pre><code class="hljs go"><span class="hljs-comment">//比较数值大小</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">less</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    v := <span class="hljs-literal">true</span>    <span class="hljs-keyword">if</span> a &gt;= b &#123;        v = <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> v&#125;<span class="hljs-comment">//换位</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exchange</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>, i , j <span class="hljs-keyword">int</span>)</span></span> &#123;    comparable[i], comparable[j] = comparable[j], comparable[i]&#125;<span class="hljs-comment">//是否排完序</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSorted</span><span class="hljs-params">(comparable []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(comparable); i++ &#123;        <span class="hljs-keyword">if</span> less(comparable[i], comparable[i<span class="hljs-number">-1</span>]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><p>参考: 算法(第四版)<br>      算法导论<br>      go源码sort包  </p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
